"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("main",{

/***/ "./node_modules/next/dist/shared/lib/router/router.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/shared/lib/router/router.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("// tslint:disable:no-console\n\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar _async_to_generator = __webpack_require__(/*! @swc/helpers/_/_async_to_generator */ \"./node_modules/@swc/helpers/esm/_async_to_generator.js\");\nvar _class_call_check = __webpack_require__(/*! @swc/helpers/_/_class_call_check */ \"./node_modules/@swc/helpers/esm/_class_call_check.js\");\nvar _create_class = __webpack_require__(/*! @swc/helpers/_/_create_class */ \"./node_modules/@swc/helpers/esm/_create_class.js\");\nvar _object_spread = __webpack_require__(/*! @swc/helpers/_/_object_spread */ \"./node_modules/@swc/helpers/esm/_object_spread.js\");\nvar _object_spread_props = __webpack_require__(/*! @swc/helpers/_/_object_spread_props */ \"./node_modules/@swc/helpers/esm/_object_spread_props.js\");\nvar _sliced_to_array = __webpack_require__(/*! @swc/helpers/_/_sliced_to_array */ \"./node_modules/@swc/helpers/esm/_sliced_to_array.js\");\nvar _ts_generator = __webpack_require__(/*! @swc/helpers/_/_ts_generator */ \"./node_modules/@swc/helpers/esm/_ts_generator.js\");\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    \"default\": function _default() {\n        return Router;\n    },\n    matchesMiddleware: function matchesMiddleware1() {\n        return matchesMiddleware;\n    },\n    createKey: function createKey1() {\n        return createKey;\n    }\n});\nvar _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nvar _interop_require_wildcard = __webpack_require__(/*! @swc/helpers/_/_interop_require_wildcard */ \"./node_modules/@swc/helpers/esm/_interop_require_wildcard.js\");\nvar _removetrailingslash = __webpack_require__(/*! ./utils/remove-trailing-slash */ \"./node_modules/next/dist/shared/lib/router/utils/remove-trailing-slash.js\");\nvar _routeloader = __webpack_require__(/*! ../../../client/route-loader */ \"./node_modules/next/dist/client/route-loader.js\");\nvar _script = __webpack_require__(/*! ../../../client/script */ \"./node_modules/next/dist/client/script.js\");\nvar _iserror = /*#__PURE__*/ _interop_require_wildcard._(__webpack_require__(/*! ../../../lib/is-error */ \"./node_modules/next/dist/lib/is-error.js\"));\nvar _denormalizepagepath = __webpack_require__(/*! ../page-path/denormalize-page-path */ \"./node_modules/next/dist/shared/lib/page-path/denormalize-page-path.js\");\nvar _normalizelocalepath = __webpack_require__(/*! ../i18n/normalize-locale-path */ \"./node_modules/next/dist/shared/lib/i18n/normalize-locale-path.js\");\nvar _mitt = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ../mitt */ \"./node_modules/next/dist/shared/lib/mitt.js\"));\nvar _utils = __webpack_require__(/*! ../utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nvar _isdynamic = __webpack_require__(/*! ./utils/is-dynamic */ \"./node_modules/next/dist/shared/lib/router/utils/is-dynamic.js\");\nvar _parserelativeurl = __webpack_require__(/*! ./utils/parse-relative-url */ \"./node_modules/next/dist/shared/lib/router/utils/parse-relative-url.js\");\nvar _resolverewrites = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! ./utils/resolve-rewrites */ \"?506d\"));\nvar _routematcher = __webpack_require__(/*! ./utils/route-matcher */ \"./node_modules/next/dist/shared/lib/router/utils/route-matcher.js\");\nvar _routeregex = __webpack_require__(/*! ./utils/route-regex */ \"./node_modules/next/dist/shared/lib/router/utils/route-regex.js\");\nvar _formaturl = __webpack_require__(/*! ./utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nvar _detectdomainlocale = __webpack_require__(/*! ../../../client/detect-domain-locale */ \"./node_modules/next/dist/client/detect-domain-locale.js\");\nvar _parsepath = __webpack_require__(/*! ./utils/parse-path */ \"./node_modules/next/dist/shared/lib/router/utils/parse-path.js\");\nvar _addlocale = __webpack_require__(/*! ../../../client/add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nvar _removelocale = __webpack_require__(/*! ../../../client/remove-locale */ \"./node_modules/next/dist/client/remove-locale.js\");\nvar _removebasepath = __webpack_require__(/*! ../../../client/remove-base-path */ \"./node_modules/next/dist/client/remove-base-path.js\");\nvar _addbasepath = __webpack_require__(/*! ../../../client/add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nvar _hasbasepath = __webpack_require__(/*! ../../../client/has-base-path */ \"./node_modules/next/dist/client/has-base-path.js\");\nvar _resolvehref = __webpack_require__(/*! ../../../client/resolve-href */ \"./node_modules/next/dist/client/resolve-href.js\");\nvar _isapiroute = __webpack_require__(/*! ../../../lib/is-api-route */ \"./node_modules/next/dist/lib/is-api-route.js\");\nvar _getnextpathnameinfo = __webpack_require__(/*! ./utils/get-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/get-next-pathname-info.js\");\nvar _formatnextpathnameinfo = __webpack_require__(/*! ./utils/format-next-pathname-info */ \"./node_modules/next/dist/shared/lib/router/utils/format-next-pathname-info.js\");\nvar _comparestates = __webpack_require__(/*! ./utils/compare-states */ \"./node_modules/next/dist/shared/lib/router/utils/compare-states.js\");\nvar _islocalurl = __webpack_require__(/*! ./utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nvar _isbot = __webpack_require__(/*! ./utils/is-bot */ \"./node_modules/next/dist/shared/lib/router/utils/is-bot.js\");\nvar _omit = __webpack_require__(/*! ./utils/omit */ \"./node_modules/next/dist/shared/lib/router/utils/omit.js\");\nvar _interpolateas = __webpack_require__(/*! ./utils/interpolate-as */ \"./node_modules/next/dist/shared/lib/router/utils/interpolate-as.js\");\nvar _handlesmoothscroll = __webpack_require__(/*! ./utils/handle-smooth-scroll */ \"./node_modules/next/dist/shared/lib/router/utils/handle-smooth-scroll.js\");\nfunction buildCancellationError() {\n    return Object.assign(new Error(\"Route Cancelled\"), {\n        cancelled: true\n    });\n}\nfunction matchesMiddleware(options) {\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction _matchesMiddleware() {\n    _matchesMiddleware = _async_to_generator._(function(options) {\n        var matchers, _ref, asPathname, cleanedAs, asWithBasePathAndLocale;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        Promise.resolve(options.router.pageLoader.getMiddleware())\n                    ];\n                case 1:\n                    matchers = _state.sent();\n                    if (!matchers) return [\n                        2,\n                        false\n                    ];\n                    _ref = (0, _parsepath.parsePath)(options.asPath), asPathname = _ref.pathname;\n                    // remove basePath first since path prefix has to be in the order of `/${basePath}/${locale}`\n                    cleanedAs = (0, _hasbasepath.hasBasePath)(asPathname) ? (0, _removebasepath.removeBasePath)(asPathname) : asPathname;\n                    asWithBasePathAndLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(cleanedAs, options.locale));\n                    // Check only path match on client. Matching \"has\" should be done on server\n                    // where we can access more info such as headers, HttpOnly cookie, etc.\n                    return [\n                        2,\n                        matchers.some(function(m) {\n                            return new RegExp(m.regexp).test(asWithBasePathAndLocale);\n                        })\n                    ];\n            }\n        });\n    });\n    return _matchesMiddleware.apply(this, arguments);\n}\nfunction stripOrigin(url) {\n    var origin = (0, _utils.getLocationOrigin)();\n    return url.startsWith(origin) ? url.substring(origin.length) : url;\n}\nfunction prepareUrlAs(router, url, as) {\n    // If url and as provided as an object representation,\n    // we'll format them into the string version here.\n    var _ref = _sliced_to_array._((0, _resolvehref.resolveHref)(router, url, true), 2), resolvedHref = _ref[0], resolvedAs = _ref[1];\n    var origin = (0, _utils.getLocationOrigin)();\n    var hrefWasAbsolute = resolvedHref.startsWith(origin);\n    var asWasAbsolute = resolvedAs && resolvedAs.startsWith(origin);\n    resolvedHref = stripOrigin(resolvedHref);\n    resolvedAs = resolvedAs ? stripOrigin(resolvedAs) : resolvedAs;\n    var preparedUrl = hrefWasAbsolute ? resolvedHref : (0, _addbasepath.addBasePath)(resolvedHref);\n    var preparedAs = as ? stripOrigin((0, _resolvehref.resolveHref)(router, as)) : resolvedAs || resolvedHref;\n    return {\n        url: preparedUrl,\n        as: asWasAbsolute ? preparedAs : (0, _addbasepath.addBasePath)(preparedAs)\n    };\n}\nfunction resolveDynamicRoute(pathname, pages) {\n    var cleanPathname = (0, _removetrailingslash.removeTrailingSlash)((0, _denormalizepagepath.denormalizePagePath)(pathname));\n    if (cleanPathname === \"/404\" || cleanPathname === \"/_error\") {\n        return pathname;\n    }\n    // handle resolving href for dynamic routes\n    if (!pages.includes(cleanPathname)) {\n        // eslint-disable-next-line array-callback-return\n        pages.some(function(page) {\n            if ((0, _isdynamic.isDynamicRoute)(page) && (0, _routeregex.getRouteRegex)(page).re.test(cleanPathname)) {\n                pathname = page;\n                return true;\n            }\n        });\n    }\n    return (0, _removetrailingslash.removeTrailingSlash)(pathname);\n}\nfunction getMiddlewareData(source, response, options) {\n    var nextConfig = {\n        basePath: options.router.basePath,\n        i18n: {\n            locales: options.router.locales\n        },\n        trailingSlash: Boolean(false)\n    };\n    var rewriteHeader = response.headers.get(\"x-nextjs-rewrite\");\n    var rewriteTarget = rewriteHeader || response.headers.get(\"x-nextjs-matched-path\");\n    var matchedPath = response.headers.get(\"x-matched-path\");\n    if (matchedPath && !rewriteTarget && !matchedPath.includes(\"__next_data_catchall\") && !matchedPath.includes(\"/_error\") && !matchedPath.includes(\"/404\")) {\n        // leverage x-matched-path to detect next.config.js rewrites\n        rewriteTarget = matchedPath;\n    }\n    if (rewriteTarget) {\n        if (rewriteTarget.startsWith(\"/\") || undefined) {\n            var parsedRewriteTarget = (0, _parserelativeurl.parseRelativeUrl)(rewriteTarget);\n            var pathnameInfo = (0, _getnextpathnameinfo.getNextPathnameInfo)(parsedRewriteTarget.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            });\n            var fsPathname = (0, _removetrailingslash.removeTrailingSlash)(pathnameInfo.pathname);\n            return Promise.all([\n                options.router.pageLoader.getPageList(),\n                (0, _routeloader.getClientBuildManifest)()\n            ]).then(function(param) {\n                var _param = _sliced_to_array._(param, 2), pages = _param[0], _param_ = _param[1], rewrites = _param_.__rewrites;\n                var as = (0, _addlocale.addLocale)(pathnameInfo.pathname, pathnameInfo.locale);\n                if ((0, _isdynamic.isDynamicRoute)(as) || !rewriteHeader && pages.includes((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(as), options.router.locales).pathname)) {\n                    var parsedSource = (0, _getnextpathnameinfo.getNextPathnameInfo)((0, _parserelativeurl.parseRelativeUrl)(source).pathname, {\n                        nextConfig:  false ? 0 : nextConfig,\n                        parseData: true\n                    });\n                    as = (0, _addbasepath.addBasePath)(parsedSource.pathname);\n                    parsedRewriteTarget.pathname = as;\n                }\n                if (false) { var result; } else if (!pages.includes(fsPathname)) {\n                    var resolvedPathname = resolveDynamicRoute(fsPathname, pages);\n                    if (resolvedPathname !== fsPathname) {\n                        fsPathname = resolvedPathname;\n                    }\n                }\n                var resolvedHref = !pages.includes(fsPathname) ? resolveDynamicRoute((0, _normalizelocalepath.normalizeLocalePath)((0, _removebasepath.removeBasePath)(parsedRewriteTarget.pathname), options.router.locales).pathname, pages) : fsPathname;\n                if ((0, _isdynamic.isDynamicRoute)(resolvedHref)) {\n                    var matches = (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(resolvedHref))(as);\n                    Object.assign(parsedRewriteTarget.query, matches || {});\n                }\n                return {\n                    type: \"rewrite\",\n                    parsedAs: parsedRewriteTarget,\n                    resolvedHref: resolvedHref\n                };\n            });\n        }\n        var src = (0, _parsepath.parsePath)(source);\n        var pathname = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src.pathname, {\n            nextConfig: nextConfig,\n            parseData: true\n        })), {\n            defaultLocale: options.router.defaultLocale,\n            buildId: \"\"\n        }));\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: \"\" + pathname + src.query + src.hash\n        });\n    }\n    var redirectTarget = response.headers.get(\"x-nextjs-redirect\");\n    if (redirectTarget) {\n        if (redirectTarget.startsWith(\"/\")) {\n            var src1 = (0, _parsepath.parsePath)(redirectTarget);\n            var pathname1 = (0, _formatnextpathnameinfo.formatNextPathnameInfo)(_object_spread_props._(_object_spread._({}, (0, _getnextpathnameinfo.getNextPathnameInfo)(src1.pathname, {\n                nextConfig: nextConfig,\n                parseData: true\n            })), {\n                defaultLocale: options.router.defaultLocale,\n                buildId: \"\"\n            }));\n            return Promise.resolve({\n                type: \"redirect-internal\",\n                newAs: \"\" + pathname1 + src1.query + src1.hash,\n                newUrl: \"\" + pathname1 + src1.query + src1.hash\n            });\n        }\n        return Promise.resolve({\n            type: \"redirect-external\",\n            destination: redirectTarget\n        });\n    }\n    return Promise.resolve({\n        type: \"next\"\n    });\n}\nfunction withMiddlewareEffects(options) {\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nfunction _withMiddlewareEffects() {\n    _withMiddlewareEffects = _async_to_generator._(function(options) {\n        var matches, data, effect, e;\n        return _ts_generator._(this, function(_state) {\n            switch(_state.label){\n                case 0:\n                    return [\n                        4,\n                        matchesMiddleware(options)\n                    ];\n                case 1:\n                    matches = _state.sent();\n                    if (!matches || !options.fetchData) {\n                        return [\n                            2,\n                            null\n                        ];\n                    }\n                    _state.label = 2;\n                case 2:\n                    _state.trys.push([\n                        2,\n                        5,\n                        ,\n                        6\n                    ]);\n                    return [\n                        4,\n                        options.fetchData()\n                    ];\n                case 3:\n                    data = _state.sent();\n                    return [\n                        4,\n                        getMiddlewareData(data.dataHref, data.response, options)\n                    ];\n                case 4:\n                    effect = _state.sent();\n                    return [\n                        2,\n                        {\n                            dataHref: data.dataHref,\n                            json: data.json,\n                            response: data.response,\n                            text: data.text,\n                            cacheKey: data.cacheKey,\n                            effect: effect\n                        }\n                    ];\n                case 5:\n                    e = _state.sent();\n                    /**\n     * TODO: Revisit this in the future.\n     * For now we will not consider middleware data errors to be fatal.\n     * maybe we should revisit in the future.\n     */ return [\n                        2,\n                        null\n                    ];\n                case 6:\n                    return [\n                        2\n                    ];\n            }\n        });\n    });\n    return _withMiddlewareEffects.apply(this, arguments);\n}\nvar manualScrollRestoration =  false && 0;\nvar SSG_DATA_NOT_FOUND = Symbol(\"SSG_DATA_NOT_FOUND\");\nfunction fetchRetry(url, attempts, options) {\n    return fetch(url, {\n        // Cookies are required to be present for Next.js' SSG \"Preview Mode\".\n        // Cookies may also be required for `getServerSideProps`.\n        //\n        // > `fetch` wonâ€™t send cookies, unless you set the credentials init\n        // > option.\n        // https://developer.mozilla.org/docs/Web/API/Fetch_API/Using_Fetch\n        //\n        // > For maximum browser compatibility when it comes to sending &\n        // > receiving cookies, always supply the `credentials: 'same-origin'`\n        // > option instead of relying on the default.\n        // https://github.com/github/fetch#caveats\n        credentials: \"same-origin\",\n        method: options.method || \"GET\",\n        headers: Object.assign({}, options.headers, {\n            \"x-nextjs-data\": \"1\"\n        })\n    }).then(function(response) {\n        return !response.ok && attempts > 1 && response.status >= 500 ? fetchRetry(url, attempts - 1, options) : response;\n    });\n}\nfunction tryToParseAsJSON(text) {\n    try {\n        return JSON.parse(text);\n    } catch (error) {\n        return null;\n    }\n}\nfunction fetchNextData(param) {\n    var dataHref = param.dataHref, inflightCache = param.inflightCache, isPrefetch = param.isPrefetch, hasMiddleware = param.hasMiddleware, isServerRender = param.isServerRender, parseJSON = param.parseJSON, persistCache = param.persistCache, isBackground = param.isBackground, unstable_skipClientCache = param.unstable_skipClientCache;\n    var _ref = new URL(dataHref, window.location.href), cacheKey = _ref.href;\n    var _params_method;\n    var getData = function(params) {\n        return fetchRetry(dataHref, isServerRender ? 3 : 1, {\n            headers: Object.assign({}, isPrefetch ? {\n                purpose: \"prefetch\"\n            } : {}, isPrefetch && hasMiddleware ? {\n                \"x-middleware-prefetch\": \"1\"\n            } : {}),\n            method: (_params_method = params == null ? void 0 : params.method) != null ? _params_method : \"GET\"\n        }).then(function(response) {\n            if (response.ok && (params == null ? void 0 : params.method) === \"HEAD\") {\n                return {\n                    dataHref: dataHref,\n                    response: response,\n                    text: \"\",\n                    json: {},\n                    cacheKey: cacheKey\n                };\n            }\n            return response.text().then(function(text) {\n                if (!response.ok) {\n                    /**\n             * When the data response is a redirect because of a middleware\n             * we do not consider it an error. The headers must bring the\n             * mapped location.\n             * TODO: Change the status code in the handler.\n             */ if (hasMiddleware && [\n                        301,\n                        302,\n                        307,\n                        308\n                    ].includes(response.status)) {\n                        return {\n                            dataHref: dataHref,\n                            response: response,\n                            text: text,\n                            json: {},\n                            cacheKey: cacheKey\n                        };\n                    }\n                    if (response.status === 404) {\n                        var _tryToParseAsJSON;\n                        if ((_tryToParseAsJSON = tryToParseAsJSON(text)) == null ? void 0 : _tryToParseAsJSON.notFound) {\n                            return {\n                                dataHref: dataHref,\n                                json: {\n                                    notFound: SSG_DATA_NOT_FOUND\n                                },\n                                response: response,\n                                text: text,\n                                cacheKey: cacheKey\n                            };\n                        }\n                    }\n                    var error = new Error(\"Failed to load static props\");\n                    /**\n             * We should only trigger a server-side transition if this was\n             * caused on a client-side transition. Otherwise, we'd get into\n             * an infinite loop.\n             */ if (!isServerRender) {\n                        (0, _routeloader.markAssetError)(error);\n                    }\n                    throw error;\n                }\n                return {\n                    dataHref: dataHref,\n                    json: parseJSON ? tryToParseAsJSON(text) : null,\n                    response: response,\n                    text: text,\n                    cacheKey: cacheKey\n                };\n            });\n        }).then(function(data) {\n            if (!persistCache || \"development\" !== \"production\" || 0) {\n                delete inflightCache[cacheKey];\n            }\n            return data;\n        })[\"catch\"](function(err) {\n            if (!unstable_skipClientCache) {\n                delete inflightCache[cacheKey];\n            }\n            if (err.message === \"Failed to fetch\" || // firefox\n            err.message === \"NetworkError when attempting to fetch resource.\" || // safari\n            err.message === \"Load failed\") {\n                (0, _routeloader.markAssetError)(err);\n            }\n            throw err;\n        });\n    };\n    // when skipping client cache we wait to update\n    // inflight cache until successful data response\n    // this allows racing click event with fetching newer data\n    // without blocking navigation when stale data is available\n    if (unstable_skipClientCache && persistCache) {\n        return getData({}).then(function(data) {\n            inflightCache[cacheKey] = Promise.resolve(data);\n            return data;\n        });\n    }\n    if (inflightCache[cacheKey] !== undefined) {\n        return inflightCache[cacheKey];\n    }\n    return inflightCache[cacheKey] = getData(isBackground ? {\n        method: \"HEAD\"\n    } : {});\n}\nfunction createKey() {\n    return Math.random().toString(36).slice(2, 10);\n}\nfunction handleHardNavigation(param) {\n    var url = param.url, router = param.router;\n    // ensure we don't trigger a hard navigation to the same\n    // URL as this can end up with an infinite refresh\n    if (url === (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(router.asPath, router.locale))) {\n        throw new Error(\"Invariant: attempted to hard navigate to the same URL \" + url + \" \" + location.href);\n    }\n    window.location.href = url;\n}\nvar getCancelledHandler = function(param) {\n    var route = param.route, router = param.router;\n    var cancelled = false;\n    var cancel = router.clc = function() {\n        cancelled = true;\n    };\n    var handleCancelled = function() {\n        if (cancelled) {\n            var error = new Error('Abort fetching component for route: \"' + route + '\"');\n            error.cancelled = true;\n            throw error;\n        }\n        if (cancel === router.clc) {\n            router.clc = null;\n        }\n    };\n    return handleCancelled;\n};\nvar Router = /*#__PURE__*/ function() {\n    function Router(pathname, query, as, param) {\n        var initialProps = param.initialProps, pageLoader = param.pageLoader, App = param.App, wrapApp = param.wrapApp, Component = param.Component, err = param.err, subscription = param.subscription, isFallback = param.isFallback, locale = param.locale, locales = param.locales, defaultLocale = param.defaultLocale, domainLocales = param.domainLocales, isPreview = param.isPreview;\n        var _this = this;\n        _class_call_check._(this, Router);\n        // Server Data Cache (full data requests)\n        this.sdc = {};\n        // Server Background Cache (HEAD requests)\n        this.sbc = {};\n        this.isFirstPopStateEvent = true;\n        this._key = createKey();\n        this.onPopState = function(e) {\n            var isFirstPopStateEvent = _this.isFirstPopStateEvent;\n            _this.isFirstPopStateEvent = false;\n            var state = e.state;\n            if (!state) {\n                // We get state as undefined for two reasons.\n                //  1. With older safari (< 8) and older chrome (< 34)\n                //  2. When the URL changed with #\n                //\n                // In the both cases, we don't need to proceed and change the route.\n                // (as it's already changed)\n                // But we can simply replace the state with the new changes.\n                // Actually, for (1) we don't need to nothing. But it's hard to detect that event.\n                // So, doing the following for (1) does no harm.\n                var _$pathname = _this.pathname, _$query = _this.query;\n                _this.changeState(\"replaceState\", (0, _formaturl.formatWithValidation)({\n                    pathname: (0, _addbasepath.addBasePath)(_$pathname),\n                    query: _$query\n                }), (0, _utils.getURL)());\n                return;\n            }\n            // __NA is used to identify if the history entry can be handled by the app-router.\n            if (state.__NA) {\n                window.location.reload();\n                return;\n            }\n            if (!state.__N) {\n                return;\n            }\n            // Safari fires popstateevent when reopening the browser.\n            if (isFirstPopStateEvent && _this.locale === state.options.locale && state.as === _this.asPath) {\n                return;\n            }\n            var forcedScroll;\n            var url = state.url, _$as = state.as, options = state.options, key = state.key;\n            if (false) { var v; }\n            _this._key = key;\n            var _$pathname1 = (0, _parserelativeurl.parseRelativeUrl)(url).pathname;\n            // Make sure we don't re-render on initial load,\n            // can be caused by navigating back from an external site\n            if (_this.isSsr && _$as === (0, _addbasepath.addBasePath)(_this.asPath) && _$pathname1 === (0, _addbasepath.addBasePath)(_this.pathname)) {\n                return;\n            }\n            // If the downstream application returns falsy, return.\n            // They will then be responsible for handling the event.\n            if (_this._bps && !_this._bps(state)) {\n                return;\n            }\n            _this.change(\"replaceState\", url, _$as, Object.assign({}, options, {\n                shallow: options.shallow && _this._shallow,\n                locale: options.locale || _this.defaultLocale,\n                // @ts-ignore internal value not exposed on types\n                _h: 0\n            }), forcedScroll);\n        };\n        // represents the current component key\n        var route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n        // set up the component cache (by route keys)\n        this.components = {};\n        // We should not keep the cache, if there's an error\n        // Otherwise, this cause issues when when going back and\n        // come again to the errored page.\n        if (pathname !== \"/_error\") {\n            this.components[route] = {\n                Component: Component,\n                initial: true,\n                props: initialProps,\n                err: err,\n                __N_SSG: initialProps && initialProps.__N_SSG,\n                __N_SSP: initialProps && initialProps.__N_SSP\n            };\n        }\n        this.components[\"/_app\"] = {\n            Component: App,\n            styleSheets: []\n        };\n        if (true) {\n            var BloomFilter = (__webpack_require__(/*! ../../lib/bloom-filter */ \"./node_modules/next/dist/shared/lib/bloom-filter.js\").BloomFilter);\n            var staticFilterData = {\"numItems\":13,\"errorRate\":0.01,\"numBits\":125,\"numHashes\":7,\"bitArray\":[0,0,0,1,1,1,1,1,1,1,1,0,0,1,1,0,1,0,1,0,0,0,1,1,1,0,0,1,1,1,0,0,0,0,1,1,0,1,0,0,0,0,1,0,0,0,1,0,1,1,0,1,0,1,0,1,0,1,1,1,0,1,0,1,1,0,1,1,0,0,1,1,0,1,1,0,0,0,1,1,1,1,0,1,0,1,1,1,0,1,0,1,1,0,0,0,1,0,1,1,1,0,1,1,0,1,1,1,1,1,0,1,0,0,0,0,1,1,1,1,1,0,0,1,1]};\n            var dynamicFilterData = {\"numItems\":0,\"errorRate\":0.01,\"numBits\":0,\"numHashes\":null,\"bitArray\":[]};\n            if (staticFilterData == null ? void 0 : staticFilterData.numHashes) {\n                this._bfl_s = new BloomFilter(staticFilterData.numItems, staticFilterData.errorRate);\n                this._bfl_s[\"import\"](staticFilterData);\n            }\n            if (dynamicFilterData == null ? void 0 : dynamicFilterData.numHashes) {\n                this._bfl_d = new BloomFilter(dynamicFilterData.numItems, dynamicFilterData.errorRate);\n                this._bfl_d[\"import\"](dynamicFilterData);\n            }\n        }\n        // Backwards compat for Router.router.events\n        // TODO: Should be remove the following major version as it was never documented\n        this.events = Router.events;\n        this.pageLoader = pageLoader;\n        // if auto prerendered and dynamic route wait to update asPath\n        // until after mount to prevent hydration mismatch\n        var autoExportDynamic = (0, _isdynamic.isDynamicRoute)(pathname) && self.__NEXT_DATA__.autoExport;\n        this.basePath =  false || \"\";\n        this.sub = subscription;\n        this.clc = null;\n        this._wrapApp = wrapApp;\n        // make sure to ignore extra popState in safari on navigating\n        // back from external site\n        this.isSsr = true;\n        this.isLocaleDomain = false;\n        this.isReady = !!(self.__NEXT_DATA__.gssp || self.__NEXT_DATA__.gip || self.__NEXT_DATA__.appGip && !self.__NEXT_DATA__.gsp || !autoExportDynamic && !self.location.search && !false);\n        if (false) {}\n        this.state = {\n            route: route,\n            pathname: pathname,\n            query: query,\n            asPath: autoExportDynamic ? pathname : as,\n            isPreview: !!isPreview,\n            locale:  false ? 0 : undefined,\n            isFallback: isFallback\n        };\n        this._initialMatchesMiddlewarePromise = Promise.resolve(false);\n        if (true) {\n            // make sure \"as\" doesn't start with double slashes or else it can\n            // throw an error as it's considered invalid\n            if (!as.startsWith(\"//\")) {\n                // in order for `e.state` to work on the `onpopstate` event\n                // we have to register the initial route upon initialization\n                var options = {\n                    locale: locale\n                };\n                var asPath = (0, _utils.getURL)();\n                this._initialMatchesMiddlewarePromise = matchesMiddleware({\n                    router: this,\n                    locale: locale,\n                    asPath: asPath\n                }).then(function(matches) {\n                    options._shouldResolveHref = as !== pathname;\n                    _this.changeState(\"replaceState\", matches ? asPath : (0, _formaturl.formatWithValidation)({\n                        pathname: (0, _addbasepath.addBasePath)(pathname),\n                        query: query\n                    }), asPath, options);\n                    return matches;\n                });\n            }\n            window.addEventListener(\"popstate\", this.onPopState);\n            // enable custom scroll restoration handling when available\n            // otherwise fallback to browser's default handling\n            if (false) {}\n        }\n    }\n    _create_class._(Router, [\n        {\n            key: \"reload\",\n            value: function reload() {\n                window.location.reload();\n            }\n        },\n        {\n            /**\n   * Go back in history\n   */ key: \"back\",\n            value: function back() {\n                window.history.back();\n            }\n        },\n        {\n            /**\n   * Go forward in history\n   */ key: \"forward\",\n            value: function forward() {\n                window.history.forward();\n            }\n        },\n        {\n            /**\n   * Performs a `pushState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"push\",\n            value: function push(url, as, options) {\n                if (options === void 0) options = {};\n                if (false) {}\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"pushState\", url, as, options);\n            }\n        },\n        {\n            /**\n   * Performs a `replaceState` with arguments\n   * @param url of the route\n   * @param as masks `url` for the browser\n   * @param options object you can define `shallow` and other options\n   */ key: \"replace\",\n            value: function replace(url, as, options) {\n                if (options === void 0) options = {};\n                var ref;\n                ref = prepareUrlAs(this, url, as), url = ref.url, as = ref.as, ref;\n                return this.change(\"replaceState\", url, as, options);\n            }\n        },\n        {\n            key: \"_bfl\",\n            value: function _bfl(as, resolvedAs, locale, skipNavigate) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var matchesBflStatic, matchesBflDynamic, _i, _iter, curAs, asNoSlash, asNoSlashLocale, _this__bfl_s, _this__bfl_s1, _i1, _iter1, normalizedAS, curAsParts, i, _this__bfl_d, currentPart;\n                    return _ts_generator._(this, function(_state) {\n                        if (true) {\n                            matchesBflStatic = false;\n                            matchesBflDynamic = false;\n                            for(_i = 0, _iter = [\n                                as,\n                                resolvedAs\n                            ]; _i < _iter.length; _i++){\n                                curAs = _iter[_i];\n                                if (curAs) {\n                                    asNoSlash = (0, _removetrailingslash.removeTrailingSlash)(new URL(curAs, \"http://n\").pathname);\n                                    asNoSlashLocale = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asNoSlash, locale || _this.locale));\n                                    if (asNoSlash !== (0, _removetrailingslash.removeTrailingSlash)(new URL(_this.asPath, \"http://n\").pathname)) {\n                                        ;\n                                        matchesBflStatic = matchesBflStatic || !!((_this__bfl_s = _this._bfl_s) == null ? void 0 : _this__bfl_s.contains(asNoSlash)) || !!((_this__bfl_s1 = _this._bfl_s) == null ? void 0 : _this__bfl_s1.contains(asNoSlashLocale));\n                                        for(_i1 = 0, _iter1 = [\n                                            asNoSlash,\n                                            asNoSlashLocale\n                                        ]; _i1 < _iter1.length; _i1++){\n                                            normalizedAS = _iter1[_i1];\n                                            // if any sub-path of as matches a dynamic filter path\n                                            // it should be hard navigated\n                                            curAsParts = normalizedAS.split(\"/\");\n                                            for(i = 0; !matchesBflDynamic && i < curAsParts.length + 1; i++){\n                                                ;\n                                                currentPart = curAsParts.slice(0, i).join(\"/\");\n                                                if (currentPart && ((_this__bfl_d = _this._bfl_d) == null ? void 0 : _this__bfl_d.contains(currentPart))) {\n                                                    matchesBflDynamic = true;\n                                                    break;\n                                                }\n                                            }\n                                        }\n                                        // if the client router filter is matched then we trigger\n                                        // a hard navigation\n                                        if (matchesBflStatic || matchesBflDynamic) {\n                                            if (skipNavigate) {\n                                                return [\n                                                    2,\n                                                    true\n                                                ];\n                                            }\n                                            handleHardNavigation({\n                                                url: (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, locale || _this.locale, _this.defaultLocale)),\n                                                router: _this\n                                            });\n                                            return [\n                                                2,\n                                                new Promise(function() {})\n                                            ];\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        return [\n                            2,\n                            false\n                        ];\n                    });\n                })();\n            }\n        },\n        {\n            key: \"change\",\n            value: function change(method, url, as, options, forcedScroll) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var _this_components_pathname, isQueryUpdating, shouldResolveHref, nextState, readyStateChange, isSsr, prevLocale, parsedAs, localePathResult, didNavigate, _this_locales, detectedDomain, asNoBasePath, _options_shallow, shallow, _options_scroll, scroll, routeProps, cleanedAs, localeChange, err, parsed, pathname, query, pages, rewrites, ref, ref1, err1, resolvedAs, route, parsedAsPathname, isMiddlewareRewrite, isMiddlewareMatch, _tmp, rewritesResult, routeMatch, parsedAs1, asPathname, routeRegex, shouldInterpolate, interpolatedAs, missingParams, isErrorRoute, _self___NEXT_DATA___props_pageProps, _self___NEXT_DATA___props, _routeInfo_props, routeInfo, cleanedParsedPathname, prefixedAs, rewriteAs, localeResult, routeRegex1, curRouteMatch, component, scripts, destination, parsedHref, _prepareUrlAs, newUrl, newAs, notFoundRoute, _, _routeInfo_route, isValidShallowRoute, _options_scroll1, shouldScroll, resetScroll, upcomingScrollState, upcomingRouterState, _self___NEXT_DATA___props_pageProps1, _self___NEXT_DATA___props1, _routeInfo_props1, err2, canSkipUpdating, e, hashRegex, err3;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (!(0, _islocalurl.isLocalURL)(url)) {\n                                    handleHardNavigation({\n                                        url: url,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                // WARNING: `_h` is an internal option for handing Next.js client-side\n                                // hydration. Your app should _never_ use this property. It may change at\n                                // any time without notice.\n                                isQueryUpdating = options._h === 1;\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    2\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, undefined, options.locale)\n                                ];\n                            case 1:\n                                _state.sent();\n                                _state.label = 2;\n                            case 2:\n                                shouldResolveHref = isQueryUpdating || options._shouldResolveHref || (0, _parsepath.parsePath)(url).pathname === (0, _parsepath.parsePath)(as).pathname;\n                                nextState = _object_spread._({}, _this.state);\n                                // for static pages with query params in the URL we delay\n                                // marking the router ready until after the query is updated\n                                // or a navigation has occurred\n                                readyStateChange = _this.isReady !== true;\n                                _this.isReady = true;\n                                isSsr = _this.isSsr;\n                                if (!isQueryUpdating) {\n                                    _this.isSsr = false;\n                                }\n                                // if a route transition is already in progress before\n                                // the query updating is triggered ignore query updating\n                                if (isQueryUpdating && _this.clc) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                prevLocale = nextState.locale;\n                                if (false) {}\n                                // marking route changes as a navigation start entry\n                                if (_utils.ST) {\n                                    performance.mark(\"routeChange\");\n                                }\n                                _options_shallow = options.shallow, shallow = _options_shallow === void 0 ? false : _options_shallow, _options_scroll = options.scroll, scroll = _options_scroll === void 0 ? true : _options_scroll;\n                                routeProps = {\n                                    shallow: shallow\n                                };\n                                if (_this._inFlightRoute && _this.clc) {\n                                    if (!isSsr) {\n                                        Router.events.emit(\"routeChangeError\", buildCancellationError(), _this._inFlightRoute, routeProps);\n                                    }\n                                    _this.clc();\n                                    _this.clc = null;\n                                }\n                                as = (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, options.locale, _this.defaultLocale));\n                                cleanedAs = (0, _removelocale.removeLocale)((0, _hasbasepath.hasBasePath)(as) ? (0, _removebasepath.removeBasePath)(as) : as, nextState.locale);\n                                _this._inFlightRoute = as;\n                                localeChange = prevLocale !== nextState.locale;\n                                if (!(!isQueryUpdating && _this.onlyAHashChange(cleanedAs) && !localeChange)) return [\n                                    3,\n                                    7\n                                ];\n                                nextState.asPath = cleanedAs;\n                                Router.events.emit(\"hashChangeStart\", as, routeProps);\n                                // TODO: do we need the resolved href when only a hash change?\n                                _this.changeState(method, url, as, _object_spread_props._(_object_spread._({}, options), {\n                                    scroll: false\n                                }));\n                                if (scroll) {\n                                    _this.scrollToHash(cleanedAs);\n                                }\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(nextState, _this.components[nextState.route], null)\n                                ];\n                            case 4:\n                                _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                err = _state.sent();\n                                if ((0, _iserror[\"default\"])(err) && err.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err, cleanedAs, routeProps);\n                                }\n                                throw err;\n                            case 6:\n                                Router.events.emit(\"hashChangeComplete\", as, routeProps);\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 7:\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                pathname = parsed.pathname, query = parsed.query;\n                                // if we detected the path as app route during prefetching\n                                // trigger hard navigation\n                                if ((_this_components_pathname = _this.components[pathname]) == null ? void 0 : _this_components_pathname.__appRouter) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _state.label = 8;\n                            case 8:\n                                _state.trys.push([\n                                    8,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader.getPageList(),\n                                        (0, _routeloader.getClientBuildManifest)(),\n                                        _this.pageLoader.getMiddleware()\n                                    ])\n                                ];\n                            case 9:\n                                ref = _sliced_to_array._.apply(void 0, [\n                                    _state.sent(),\n                                    2\n                                ]), pages = ref[0], ref1 = ref[1], rewrites = ref1.__rewrites, ref1, ref;\n                                return [\n                                    3,\n                                    11\n                                ];\n                            case 10:\n                                err1 = _state.sent();\n                                // If we fail to resolve the page list or client-build manifest, we must\n                                // do a server-side transition:\n                                handleHardNavigation({\n                                    url: as,\n                                    router: _this\n                                });\n                                return [\n                                    2,\n                                    false\n                                ];\n                            case 11:\n                                // If asked to change the current URL we should reload the current page\n                                // (not location.reload() but reload getInitialProps and other Next.js stuffs)\n                                // We also need to set the method = replaceState always\n                                // as this should not go into the history (That's how browsers work)\n                                // We should compare the new asPath to the current asPath, not the url\n                                if (!_this.urlIsNew(cleanedAs) && !localeChange) {\n                                    method = \"replaceState\";\n                                }\n                                // we need to resolve the as value using rewrites for dynamic SSG\n                                // pages to allow building the data URL correctly\n                                resolvedAs = as;\n                                // url and as should always be prefixed with basePath by this\n                                // point by either next/link or router.push/replace so strip the\n                                // basePath from the pathname to match the pages dir 1-to-1\n                                pathname = pathname ? (0, _removetrailingslash.removeTrailingSlash)((0, _removebasepath.removeBasePath)(pathname)) : pathname;\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                parsedAsPathname = as.startsWith(\"/\") && (0, _parserelativeurl.parseRelativeUrl)(as).pathname;\n                                isMiddlewareRewrite = !!(parsedAsPathname && route !== parsedAsPathname && (!(0, _isdynamic.isDynamicRoute)(route) || !(0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(route))(parsedAsPathname)));\n                                _tmp = !options.shallow;\n                                if (!_tmp) return [\n                                    3,\n                                    13\n                                ];\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: as,\n                                        locale: nextState.locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 12:\n                                _tmp = _state.sent();\n                                _state.label = 13;\n                            case 13:\n                                isMiddlewareMatch = _tmp;\n                                if (isQueryUpdating && isMiddlewareMatch) {\n                                    shouldResolveHref = false;\n                                }\n                                if (shouldResolveHref && pathname !== \"/_error\") {\n                                    options._shouldResolveHref = true;\n                                    if (false) {} else {\n                                        parsed.pathname = resolveDynamicRoute(pathname, pages);\n                                        if (parsed.pathname !== pathname) {\n                                            pathname = parsed.pathname;\n                                            parsed.pathname = (0, _addbasepath.addBasePath)(pathname);\n                                            if (!isMiddlewareMatch) {\n                                                url = (0, _formaturl.formatWithValidation)(parsed);\n                                            }\n                                        }\n                                    }\n                                }\n                                if (!(0, _islocalurl.isLocalURL)(as)) {\n                                    if (true) {\n                                        throw new Error('Invalid href: \"' + url + '\" and as: \"' + as + '\", received relative href and external as' + \"\\nSee more info: https://nextjs.org/docs/messages/invalid-relative-url-external-as\");\n                                    }\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(resolvedAs), nextState.locale);\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                routeMatch = false;\n                                if ((0, _isdynamic.isDynamicRoute)(route)) {\n                                    parsedAs1 = (0, _parserelativeurl.parseRelativeUrl)(resolvedAs);\n                                    asPathname = parsedAs1.pathname;\n                                    routeRegex = (0, _routeregex.getRouteRegex)(route);\n                                    routeMatch = (0, _routematcher.getRouteMatcher)(routeRegex)(asPathname);\n                                    shouldInterpolate = route === asPathname;\n                                    interpolatedAs = shouldInterpolate ? (0, _interpolateas.interpolateAs)(route, asPathname, query) : {};\n                                    if (!routeMatch || shouldInterpolate && !interpolatedAs.result) {\n                                        missingParams = Object.keys(routeRegex.groups).filter(function(param) {\n                                            return !query[param] && !routeRegex.groups[param].optional;\n                                        });\n                                        if (missingParams.length > 0 && !isMiddlewareMatch) {\n                                            if (true) {\n                                                console.warn(\"\" + (shouldInterpolate ? \"Interpolating href\" : \"Mismatching `as` and `href`\") + \" failed to manually provide \" + (\"the params: \" + missingParams.join(\", \") + \" in the `href`'s `query`\"));\n                                            }\n                                            throw new Error((shouldInterpolate ? \"The provided `href` (\" + url + \") value is missing query values (\" + missingParams.join(\", \") + \") to be interpolated properly. \" : \"The provided `as` value (\" + asPathname + \") is incompatible with the `href` value (\" + route + \"). \") + (\"Read more: https://nextjs.org/docs/messages/\" + (shouldInterpolate ? \"href-interpolation-failed\" : \"incompatible-href-as\")));\n                                        }\n                                    } else if (shouldInterpolate) {\n                                        as = (0, _formaturl.formatWithValidation)(Object.assign({}, parsedAs1, {\n                                            pathname: interpolatedAs.result,\n                                            query: (0, _omit.omit)(query, interpolatedAs.params)\n                                        }));\n                                    } else {\n                                        // Merge params into `query`, overwriting any specified in search\n                                        Object.assign(query, routeMatch);\n                                    }\n                                }\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeStart\", as, routeProps);\n                                }\n                                isErrorRoute = _this.pathname === \"/404\" || _this.pathname === \"/_error\";\n                                _state.label = 14;\n                            case 14:\n                                _state.trys.push([\n                                    14,\n                                    35,\n                                    ,\n                                    36\n                                ]);\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: route,\n                                        pathname: pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: routeProps,\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        hasMiddleware: isMiddlewareMatch,\n                                        unstable_skipClientCache: options.unstable_skipClientCache,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback,\n                                        isMiddlewareRewrite: isMiddlewareRewrite\n                                    })\n                                ];\n                            case 15:\n                                routeInfo = _state.sent();\n                                if (!(!isQueryUpdating && !options.shallow)) return [\n                                    3,\n                                    17\n                                ];\n                                return [\n                                    4,\n                                    _this._bfl(as, \"resolvedAs\" in routeInfo ? routeInfo.resolvedAs : undefined, nextState.locale)\n                                ];\n                            case 16:\n                                _state.sent();\n                                _state.label = 17;\n                            case 17:\n                                if (\"route\" in routeInfo && isMiddlewareMatch) {\n                                    pathname = routeInfo.route || route;\n                                    route = pathname;\n                                    if (!routeProps.shallow) {\n                                        query = Object.assign({}, routeInfo.query || {}, query);\n                                    }\n                                    cleanedParsedPathname = (0, _hasbasepath.hasBasePath)(parsed.pathname) ? (0, _removebasepath.removeBasePath)(parsed.pathname) : parsed.pathname;\n                                    if (routeMatch && pathname !== cleanedParsedPathname) {\n                                        Object.keys(routeMatch).forEach(function(key) {\n                                            if (routeMatch && query[key] === routeMatch[key]) {\n                                                delete query[key];\n                                            }\n                                        });\n                                    }\n                                    if ((0, _isdynamic.isDynamicRoute)(pathname)) {\n                                        prefixedAs = !routeProps.shallow && routeInfo.resolvedAs ? routeInfo.resolvedAs : (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(new URL(as, location.href).pathname, nextState.locale), true);\n                                        rewriteAs = prefixedAs;\n                                        if ((0, _hasbasepath.hasBasePath)(rewriteAs)) {\n                                            rewriteAs = (0, _removebasepath.removeBasePath)(rewriteAs);\n                                        }\n                                        if (false) {}\n                                        routeRegex1 = (0, _routeregex.getRouteRegex)(pathname);\n                                        curRouteMatch = (0, _routematcher.getRouteMatcher)(routeRegex1)(new URL(rewriteAs, location.href).pathname);\n                                        if (curRouteMatch) {\n                                            Object.assign(query, curRouteMatch);\n                                        }\n                                    }\n                                }\n                                // If the routeInfo brings a redirect we simply apply it.\n                                if (\"type\" in routeInfo) {\n                                    if (routeInfo.type === \"redirect-internal\") {\n                                        return [\n                                            2,\n                                            _this.change(method, routeInfo.newUrl, routeInfo.newAs, options)\n                                        ];\n                                    } else {\n                                        handleHardNavigation({\n                                            url: routeInfo.destination,\n                                            router: _this\n                                        });\n                                        return [\n                                            2,\n                                            new Promise(function() {})\n                                        ];\n                                    }\n                                }\n                                component = routeInfo.Component;\n                                if (component && component.unstable_scriptLoader) {\n                                    scripts = [].concat(component.unstable_scriptLoader());\n                                    scripts.forEach(function(script) {\n                                        (0, _script.handleClientScriptLoad)(script.props);\n                                    });\n                                }\n                                if (!((routeInfo.__N_SSG || routeInfo.__N_SSP) && routeInfo.props)) return [\n                                    3,\n                                    23\n                                ];\n                                if (routeInfo.props.pageProps && routeInfo.props.pageProps.__N_REDIRECT) {\n                                    // Use the destination from redirect without adding locale\n                                    options.locale = false;\n                                    destination = routeInfo.props.pageProps.__N_REDIRECT;\n                                    // check if destination is internal (resolves to a page) and attempt\n                                    // client-navigation if it is falling back to hard navigation if\n                                    // it's not\n                                    if (destination.startsWith(\"/\") && routeInfo.props.pageProps.__N_REDIRECT_BASE_PATH !== false) {\n                                        parsedHref = (0, _parserelativeurl.parseRelativeUrl)(destination);\n                                        parsedHref.pathname = resolveDynamicRoute(parsedHref.pathname, pages);\n                                        _prepareUrlAs = prepareUrlAs(_this, destination, destination), newUrl = _prepareUrlAs.url, newAs = _prepareUrlAs.as;\n                                        return [\n                                            2,\n                                            _this.change(method, newUrl, newAs, options)\n                                        ];\n                                    }\n                                    handleHardNavigation({\n                                        url: destination,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                nextState.isPreview = !!routeInfo.props.__N_PREVIEW;\n                                if (!(routeInfo.props.notFound === SSG_DATA_NOT_FOUND)) return [\n                                    3,\n                                    23\n                                ];\n                                _state.label = 18;\n                            case 18:\n                                _state.trys.push([\n                                    18,\n                                    20,\n                                    ,\n                                    21\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/404\")\n                                ];\n                            case 19:\n                                _state.sent();\n                                notFoundRoute = \"/404\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 20:\n                                _ = _state.sent();\n                                notFoundRoute = \"/_error\";\n                                return [\n                                    3,\n                                    21\n                                ];\n                            case 21:\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: notFoundRoute,\n                                        pathname: notFoundRoute,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isNotFound: true\n                                    })\n                                ];\n                            case 22:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on /404\");\n                                }\n                                _state.label = 23;\n                            case 23:\n                                if (isQueryUpdating && _this.pathname === \"/_error\" && ((_self___NEXT_DATA___props = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps = _self___NEXT_DATA___props.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps.statusCode) === 500 && ((_routeInfo_props = routeInfo.props) == null ? void 0 : _routeInfo_props.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                // shallow routing is only allowed for same page URL changes.\n                                isValidShallowRoute = options.shallow && nextState.route === ((_routeInfo_route = routeInfo.route) != null ? _routeInfo_route : route);\n                                shouldScroll = (_options_scroll1 = options.scroll) != null ? _options_scroll1 : !isQueryUpdating && !isValidShallowRoute;\n                                resetScroll = shouldScroll ? {\n                                    x: 0,\n                                    y: 0\n                                } : null;\n                                upcomingScrollState = forcedScroll != null ? forcedScroll : resetScroll;\n                                // the new state that the router gonna set\n                                upcomingRouterState = _object_spread_props._(_object_spread._({}, nextState), {\n                                    route: route,\n                                    pathname: pathname,\n                                    query: query,\n                                    asPath: cleanedAs,\n                                    isFallback: false\n                                });\n                                if (!(isQueryUpdating && isErrorRoute)) return [\n                                    3,\n                                    29\n                                ];\n                                return [\n                                    4,\n                                    _this.getRouteInfo({\n                                        route: _this.pathname,\n                                        pathname: _this.pathname,\n                                        query: query,\n                                        as: as,\n                                        resolvedAs: resolvedAs,\n                                        routeProps: {\n                                            shallow: false\n                                        },\n                                        locale: nextState.locale,\n                                        isPreview: nextState.isPreview,\n                                        isQueryUpdating: isQueryUpdating && !_this.isFallback\n                                    })\n                                ];\n                            case 24:\n                                routeInfo = _state.sent();\n                                if (\"type\" in routeInfo) {\n                                    throw new Error(\"Unexpected middleware effect on \" + _this.pathname);\n                                }\n                                if (_this.pathname === \"/_error\" && ((_self___NEXT_DATA___props1 = self.__NEXT_DATA__.props) == null ? void 0 : (_self___NEXT_DATA___props_pageProps1 = _self___NEXT_DATA___props1.pageProps) == null ? void 0 : _self___NEXT_DATA___props_pageProps1.statusCode) === 500 && ((_routeInfo_props1 = routeInfo.props) == null ? void 0 : _routeInfo_props1.pageProps)) {\n                                    // ensure statusCode is still correct for static 500 page\n                                    // when updating query information\n                                    routeInfo.props.pageProps.statusCode = 500;\n                                }\n                                _state.label = 25;\n                            case 25:\n                                _state.trys.push([\n                                    25,\n                                    27,\n                                    ,\n                                    28\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 26:\n                                _state.sent();\n                                return [\n                                    3,\n                                    28\n                                ];\n                            case 27:\n                                err2 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err2) && err2.cancelled) {\n                                    Router.events.emit(\"routeChangeError\", err2, cleanedAs, routeProps);\n                                }\n                                throw err2;\n                            case 28:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 29:\n                                Router.events.emit(\"beforeHistoryChange\", as, routeProps);\n                                _this.changeState(method, url, as, options);\n                                // for query updates we can skip it if the state is unchanged and we don't\n                                // need to scroll\n                                // https://github.com/vercel/next.js/issues/37139\n                                canSkipUpdating = isQueryUpdating && !upcomingScrollState && !readyStateChange && !localeChange && (0, _comparestates.compareRouterStates)(upcomingRouterState, _this.state);\n                                if (!!canSkipUpdating) return [\n                                    3,\n                                    34\n                                ];\n                                _state.label = 30;\n                            case 30:\n                                _state.trys.push([\n                                    30,\n                                    32,\n                                    ,\n                                    33\n                                ]);\n                                return [\n                                    4,\n                                    _this.set(upcomingRouterState, routeInfo, upcomingScrollState)\n                                ];\n                            case 31:\n                                _state.sent();\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 32:\n                                e = _state.sent();\n                                if (e.cancelled) routeInfo.error = routeInfo.error || e;\n                                else throw e;\n                                return [\n                                    3,\n                                    33\n                                ];\n                            case 33:\n                                if (routeInfo.error) {\n                                    if (!isQueryUpdating) {\n                                        Router.events.emit(\"routeChangeError\", routeInfo.error, cleanedAs, routeProps);\n                                    }\n                                    throw routeInfo.error;\n                                }\n                                if (false) {}\n                                if (!isQueryUpdating) {\n                                    Router.events.emit(\"routeChangeComplete\", as, routeProps);\n                                }\n                                // A hash mark # is the optional last part of a URL\n                                hashRegex = /#.+$/;\n                                if (shouldScroll && hashRegex.test(as)) {\n                                    _this.scrollToHash(as);\n                                }\n                                _state.label = 34;\n                            case 34:\n                                return [\n                                    2,\n                                    true\n                                ];\n                            case 35:\n                                err3 = _state.sent();\n                                if ((0, _iserror[\"default\"])(err3) && err3.cancelled) {\n                                    return [\n                                        2,\n                                        false\n                                    ];\n                                }\n                                throw err3;\n                            case 36:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"changeState\",\n            value: function changeState(method, url, as, options) {\n                if (options === void 0) options = {};\n                if (true) {\n                    if (typeof window.history === \"undefined\") {\n                        console.error(\"Warning: window.history is not available.\");\n                        return;\n                    }\n                    if (typeof window.history[method] === \"undefined\") {\n                        console.error(\"Warning: window.history.\" + method + \" is not available\");\n                        return;\n                    }\n                }\n                if (method !== \"pushState\" || (0, _utils.getURL)() !== as) {\n                    this._shallow = options.shallow;\n                    window.history[method]({\n                        url: url,\n                        as: as,\n                        options: options,\n                        __N: true,\n                        key: this._key = method !== \"pushState\" ? this._key : createKey()\n                    }, // Passing the empty string here should be safe against future changes to the method.\n                    // https://developer.mozilla.org/docs/Web/API/History/replaceState\n                    \"\", as);\n                }\n            }\n        },\n        {\n            key: \"handleRouteInfoError\",\n            value: function handleRouteInfoError(err, pathname, query, as, routeProps, loadErrorFail) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var props, _ref, Component, styleSheets, routeInfo, gipErr, routeInfoErr;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                console.error(err);\n                                if (err.cancelled) {\n                                    // bubble up cancellation errors\n                                    throw err;\n                                }\n                                if ((0, _routeloader.isAssetError)(err) || loadErrorFail) {\n                                    Router.events.emit(\"routeChangeError\", err, as, routeProps);\n                                    // If we can't load the page it could be one of following reasons\n                                    //  1. Page doesn't exists\n                                    //  2. Page does exist in a different zone\n                                    //  3. Internal error while loading the page\n                                    // So, doing a hard reload is the proper way to deal with this.\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    // Changing the URL doesn't block executing the current code path.\n                                    // So let's throw a cancellation error stop the routing logic.\n                                    throw buildCancellationError();\n                                }\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    7,\n                                    ,\n                                    8\n                                ]);\n                                return [\n                                    4,\n                                    _this.fetchComponent(\"/_error\")\n                                ];\n                            case 2:\n                                _ref = _state.sent(), Component = _ref.page, styleSheets = _ref.styleSheets;\n                                routeInfo = {\n                                    props: props,\n                                    Component: Component,\n                                    styleSheets: styleSheets,\n                                    err: err,\n                                    error: err\n                                };\n                                if (!!routeInfo.props) return [\n                                    3,\n                                    6\n                                ];\n                                _state.label = 3;\n                            case 3:\n                                _state.trys.push([\n                                    3,\n                                    5,\n                                    ,\n                                    6\n                                ]);\n                                return [\n                                    4,\n                                    _this.getInitialProps(Component, {\n                                        err: err,\n                                        pathname: pathname,\n                                        query: query\n                                    })\n                                ];\n                            case 4:\n                                routeInfo.props = _state.sent();\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 5:\n                                gipErr = _state.sent();\n                                console.error(\"Error in error page `getInitialProps`: \", gipErr);\n                                routeInfo.props = {};\n                                return [\n                                    3,\n                                    6\n                                ];\n                            case 6:\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 7:\n                                routeInfoErr = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror[\"default\"])(routeInfoErr) ? routeInfoErr : new Error(routeInfoErr + \"\"), pathname, query, as, routeProps, true)\n                                ];\n                            case 8:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"getRouteInfo\",\n            value: function getRouteInfo(param) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var requestedRoute, pathname, query, as, resolvedAs, routeProps, locale, hasMiddleware, isPreview, unstable_skipClientCache, isQueryUpdating, isMiddlewareRewrite, isNotFound, route, _data_effect, _data_effect1, _data_effect2, _data_response, handleCancelled, existingInfo, cachedRouteInfo, isBackground, fetchNextDataParams, data, _tmp, resolvedRoute, pages, routeInfo, _tmp1, isValidElementType, wasBailedPrefetch, shouldFetchData, _ref, props, cacheKey, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                requestedRoute = param.route, pathname = param.pathname, query = param.query, as = param.as, resolvedAs = param.resolvedAs, routeProps = param.routeProps, locale = param.locale, hasMiddleware = param.hasMiddleware, isPreview = param.isPreview, unstable_skipClientCache = param.unstable_skipClientCache, isQueryUpdating = param.isQueryUpdating, isMiddlewareRewrite = param.isMiddlewareRewrite, isNotFound = param.isNotFound;\n                                /**\n     * This `route` binding can change if there's a rewrite\n     * so we keep a reference to the original requested route\n     * so we can store the cache for it and avoid re-requesting every time\n     * for shallow routing purposes.\n     */ route = requestedRoute;\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    10,\n                                    ,\n                                    11\n                                ]);\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                existingInfo = _this.components[route];\n                                if (routeProps.shallow && existingInfo && _this.route === route) {\n                                    return [\n                                        2,\n                                        existingInfo\n                                    ];\n                                }\n                                if (hasMiddleware) {\n                                    existingInfo = undefined;\n                                }\n                                cachedRouteInfo = existingInfo && !(\"initial\" in existingInfo) && \"development\" !== \"development\" ? 0 : undefined;\n                                isBackground = isQueryUpdating;\n                                fetchNextDataParams = {\n                                    dataHref: _this.pageLoader.getDataHref({\n                                        href: (0, _formaturl.formatWithValidation)({\n                                            pathname: pathname,\n                                            query: query\n                                        }),\n                                        skipInterpolation: true,\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale\n                                    }),\n                                    hasMiddleware: true,\n                                    isServerRender: _this.isSsr,\n                                    parseJSON: true,\n                                    inflightCache: isBackground ? _this.sbc : _this.sdc,\n                                    persistCache: !isPreview,\n                                    isPrefetch: false,\n                                    unstable_skipClientCache: unstable_skipClientCache,\n                                    isBackground: isBackground\n                                };\n                                if (!(isQueryUpdating && !isMiddlewareRewrite)) return [\n                                    3,\n                                    2\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    4\n                                ];\n                            case 2:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData(fetchNextDataParams);\n                                        },\n                                        asPath: isNotFound ? \"/404\" : resolvedAs,\n                                        locale: locale,\n                                        router: _this\n                                    })[\"catch\"](function(err) {\n                                        // we don't hard error during query updating\n                                        // as it's un-necessary and doesn't need to be fatal\n                                        // unless it is a fallback route and the props can't\n                                        // be loaded\n                                        if (isQueryUpdating) {\n                                            return null;\n                                        }\n                                        throw err;\n                                    })\n                                ];\n                            case 3:\n                                _tmp = _state.sent();\n                                _state.label = 4;\n                            case 4:\n                                data = _tmp;\n                                // when rendering error routes we don't apply middleware\n                                // effects\n                                if (data && (pathname === \"/_error\" || pathname === \"/404\")) {\n                                    data.effect = undefined;\n                                }\n                                if (isQueryUpdating) {\n                                    if (!data) {\n                                        data = {\n                                            json: self.__NEXT_DATA__.props\n                                        };\n                                    } else {\n                                        data.json = self.__NEXT_DATA__.props;\n                                    }\n                                }\n                                handleCancelled();\n                                if ((data == null ? void 0 : (_data_effect = data.effect) == null ? void 0 : _data_effect.type) === \"redirect-internal\" || (data == null ? void 0 : (_data_effect1 = data.effect) == null ? void 0 : _data_effect1.type) === \"redirect-external\") {\n                                    return [\n                                        2,\n                                        data.effect\n                                    ];\n                                }\n                                if (!((data == null ? void 0 : (_data_effect2 = data.effect) == null ? void 0 : _data_effect2.type) === \"rewrite\")) return [\n                                    3,\n                                    6\n                                ];\n                                resolvedRoute = (0, _removetrailingslash.removeTrailingSlash)(data.effect.resolvedHref);\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 5:\n                                pages = _state.sent();\n                                // during query updating the page must match although during\n                                // client-transition a redirect that doesn't match a page\n                                // can be returned and this should trigger a hard navigation\n                                // which is valid for incremental migration\n                                if (!isQueryUpdating || pages.includes(resolvedRoute)) {\n                                    route = resolvedRoute;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = (0, _removebasepath.removeBasePath)((0, _normalizelocalepath.normalizeLocalePath)(data.effect.parsedAs.pathname, _this.locales).pathname);\n                                    // Check again the cache with the new destination.\n                                    existingInfo = _this.components[route];\n                                    if (routeProps.shallow && existingInfo && _this.route === route && !hasMiddleware) {\n                                        // If we have a match with the current route due to rewrite,\n                                        // we can copy the existing information to the rewritten one.\n                                        // Then, we return the information along with the matched route.\n                                        return [\n                                            2,\n                                            _object_spread_props._(_object_spread._({}, existingInfo), {\n                                                route: route\n                                            })\n                                        ];\n                                    }\n                                }\n                                _state.label = 6;\n                            case 6:\n                                if ((0, _isapiroute.isAPIRoute)(route)) {\n                                    handleHardNavigation({\n                                        url: as,\n                                        router: _this\n                                    });\n                                    return [\n                                        2,\n                                        new Promise(function() {})\n                                    ];\n                                }\n                                _tmp1 = cachedRouteInfo;\n                                if (_tmp1) return [\n                                    3,\n                                    8\n                                ];\n                                return [\n                                    4,\n                                    _this.fetchComponent(route).then(function(res) {\n                                        return {\n                                            Component: res.page,\n                                            styleSheets: res.styleSheets,\n                                            __N_SSG: res.mod.__N_SSG,\n                                            __N_SSP: res.mod.__N_SSP\n                                        };\n                                    })\n                                ];\n                            case 7:\n                                _tmp1 = _state.sent();\n                                _state.label = 8;\n                            case 8:\n                                routeInfo = _tmp1;\n                                if (true) {\n                                    isValidElementType = (__webpack_require__(/*! next/dist/compiled/react-is */ \"./node_modules/next/dist/compiled/react-is/index.js\").isValidElementType);\n                                    if (!isValidElementType(routeInfo.Component)) {\n                                        throw new Error('The default export is not a React Component in page: \"' + pathname + '\"');\n                                    }\n                                }\n                                wasBailedPrefetch = data == null ? void 0 : (_data_response = data.response) == null ? void 0 : _data_response.headers.get(\"x-middleware-skip\");\n                                shouldFetchData = routeInfo.__N_SSG || routeInfo.__N_SSP;\n                                // For non-SSG prefetches that bailed before sending data\n                                // we clear the cache to fetch full response\n                                if (wasBailedPrefetch && (data == null ? void 0 : data.dataHref)) {\n                                    delete _this.sdc[data.dataHref];\n                                }\n                                return [\n                                    4,\n                                    _this._getData(/*#__PURE__*/ _async_to_generator._(function() {\n                                        var dataHref, fetched, _tmp;\n                                        return _ts_generator._(this, function(_state) {\n                                            switch(_state.label){\n                                                case 0:\n                                                    if (!shouldFetchData) return [\n                                                        3,\n                                                        2\n                                                    ];\n                                                    if ((data == null ? void 0 : data.json) && !wasBailedPrefetch) {\n                                                        return [\n                                                            2,\n                                                            {\n                                                                cacheKey: data.cacheKey,\n                                                                props: data.json\n                                                            }\n                                                        ];\n                                                    }\n                                                    dataHref = (data == null ? void 0 : data.dataHref) ? data.dataHref : _this.pageLoader.getDataHref({\n                                                        href: (0, _formaturl.formatWithValidation)({\n                                                            pathname: pathname,\n                                                            query: query\n                                                        }),\n                                                        asPath: resolvedAs,\n                                                        locale: locale\n                                                    });\n                                                    return [\n                                                        4,\n                                                        fetchNextData({\n                                                            dataHref: dataHref,\n                                                            isServerRender: _this.isSsr,\n                                                            parseJSON: true,\n                                                            inflightCache: wasBailedPrefetch ? {} : _this.sdc,\n                                                            persistCache: !isPreview,\n                                                            isPrefetch: false,\n                                                            unstable_skipClientCache: unstable_skipClientCache\n                                                        })\n                                                    ];\n                                                case 1:\n                                                    fetched = _state.sent();\n                                                    return [\n                                                        2,\n                                                        {\n                                                            cacheKey: fetched.cacheKey,\n                                                            props: fetched.json || {}\n                                                        }\n                                                    ];\n                                                case 2:\n                                                    _tmp = {\n                                                        headers: {}\n                                                    };\n                                                    return [\n                                                        4,\n                                                        _this.getInitialProps(routeInfo.Component, {\n                                                            pathname: pathname,\n                                                            query: query,\n                                                            asPath: as,\n                                                            locale: locale,\n                                                            locales: _this.locales,\n                                                            defaultLocale: _this.defaultLocale\n                                                        })\n                                                    ];\n                                                case 3:\n                                                    return [\n                                                        2,\n                                                        (_tmp.props = _state.sent(), _tmp)\n                                                    ];\n                                            }\n                                        });\n                                    }))\n                                ];\n                            case 9:\n                                _ref = _state.sent(), props = _ref.props, cacheKey = _ref.cacheKey;\n                                // Only bust the data cache for SSP routes although\n                                // middleware can skip cache per request with\n                                // x-middleware-cache: no-cache as well\n                                if (routeInfo.__N_SSP && fetchNextDataParams.dataHref && cacheKey) {\n                                    delete _this.sdc[cacheKey];\n                                }\n                                // we kick off a HEAD request in the background\n                                // when a non-prefetch request is made to signal revalidation\n                                if (!_this.isPreview && routeInfo.__N_SSG && \"development\" !== \"development\" && 0) {}\n                                props.pageProps = Object.assign({}, props.pageProps);\n                                routeInfo.props = props;\n                                routeInfo.route = route;\n                                routeInfo.query = query;\n                                routeInfo.resolvedAs = resolvedAs;\n                                _this.components[route] = routeInfo;\n                                return [\n                                    2,\n                                    routeInfo\n                                ];\n                            case 10:\n                                err = _state.sent();\n                                return [\n                                    2,\n                                    _this.handleRouteInfoError((0, _iserror.getProperError)(err), pathname, query, as, routeProps)\n                                ];\n                            case 11:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"set\",\n            value: function set(state, data, resetScroll) {\n                this.state = state;\n                return this.sub(data, this.components[\"/_app\"].Component, resetScroll);\n            }\n        },\n        {\n            /**\n   * Callback to execute before replacing router state\n   * @param cb callback to be executed\n   */ key: \"beforePopState\",\n            value: function beforePopState(cb) {\n                this._bps = cb;\n            }\n        },\n        {\n            key: \"onlyAHashChange\",\n            value: function onlyAHashChange(as) {\n                if (!this.asPath) return false;\n                var _this_asPath_split = _sliced_to_array._(this.asPath.split(\"#\"), 2), oldUrlNoHash = _this_asPath_split[0], oldHash = _this_asPath_split[1];\n                var _as_split = _sliced_to_array._(as.split(\"#\"), 2), newUrlNoHash = _as_split[0], newHash = _as_split[1];\n                // Makes sure we scroll to the provided hash if the url/hash are the same\n                if (newHash && oldUrlNoHash === newUrlNoHash && oldHash === newHash) {\n                    return true;\n                }\n                // If the urls are change, there's more than a hash change\n                if (oldUrlNoHash !== newUrlNoHash) {\n                    return false;\n                }\n                // If the hash has changed, then it's a hash only change.\n                // This check is necessary to handle both the enter and\n                // leave hash === '' cases. The identity case falls through\n                // and is treated as a next reload.\n                return oldHash !== newHash;\n            }\n        },\n        {\n            key: \"scrollToHash\",\n            value: function scrollToHash(as) {\n                var _as_split = _sliced_to_array._(as.split(\"#\"), 2), tmp = _as_split[1], hash = tmp === void 0 ? \"\" : tmp;\n                (0, _handlesmoothscroll.handleSmoothScroll)(function() {\n                    // Scroll to top if the hash is just `#` with no value or `#top`\n                    // To mirror browsers\n                    if (hash === \"\" || hash === \"top\") {\n                        window.scrollTo(0, 0);\n                        return;\n                    }\n                    // Decode hash to make non-latin anchor works.\n                    var rawHash = decodeURIComponent(hash);\n                    // First we check if the element by id is found\n                    var idEl = document.getElementById(rawHash);\n                    if (idEl) {\n                        idEl.scrollIntoView();\n                        return;\n                    }\n                    // If there's no element with the id, we check the `name` property\n                    // To mirror browsers\n                    var nameEl = document.getElementsByName(rawHash)[0];\n                    if (nameEl) {\n                        nameEl.scrollIntoView();\n                    }\n                }, {\n                    onlyHashChange: this.onlyAHashChange(as)\n                });\n            }\n        },\n        {\n            key: \"urlIsNew\",\n            value: function urlIsNew(asPath) {\n                return this.asPath !== asPath;\n            }\n        },\n        {\n            key: \"prefetch\",\n            value: /**\n   * Prefetch page code, you may wait for the data during page rendering.\n   * This feature only works in production!\n   * @param url the href of prefetched page\n   * @param asPath the as path of the prefetched page\n   */ function prefetch(url, asPath, options) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var parsed, urlPathname, pathname, query, originalPathname, parsedAs, localePathResult, pages, resolvedAs, locale, isMiddlewareMatch, rewrites, ref, rewritesResult, data, _tmp, route;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                if (asPath === void 0) asPath = url;\n                                if (options === void 0) options = {};\n                                // Prefetch is not supported in development mode because it would trigger on-demand-entries\n                                if (true) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if ( true && (0, _isbot.isBot)(window.navigator.userAgent)) {\n                                    // No prefetches for bots that render the link since they are typically navigating\n                                    // links via the equivalent of a hard navigation and hence never utilize these\n                                    // prefetches.\n                                    return [\n                                        2\n                                    ];\n                                }\n                                parsed = (0, _parserelativeurl.parseRelativeUrl)(url);\n                                urlPathname = parsed.pathname;\n                                pathname = parsed.pathname, query = parsed.query;\n                                originalPathname = pathname;\n                                if (false) {}\n                                return [\n                                    4,\n                                    _this.pageLoader.getPageList()\n                                ];\n                            case 1:\n                                pages = _state.sent();\n                                resolvedAs = asPath;\n                                locale = typeof options.locale !== \"undefined\" ? options.locale || undefined : _this.locale;\n                                return [\n                                    4,\n                                    matchesMiddleware({\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 2:\n                                isMiddlewareMatch = _state.sent();\n                                if (true) return [\n                                    3,\n                                    4\n                                ];\n                                return [\n                                    4,\n                                    (0, _routeloader.getClientBuildManifest)()\n                                ];\n                            case 3:\n                                ref = _state.sent(), rewrites = ref.__rewrites, ref;\n                                rewritesResult = (0, _resolverewrites[\"default\"])((0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(asPath, _this.locale), true), pages, rewrites, parsed.query, function(p) {\n                                    return resolveDynamicRoute(p, pages);\n                                }, _this.locales);\n                                if (rewritesResult.externalDest) {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                if (!isMiddlewareMatch) {\n                                    resolvedAs = (0, _removelocale.removeLocale)((0, _removebasepath.removeBasePath)(rewritesResult.asPath), _this.locale);\n                                }\n                                if (rewritesResult.matchedPage && rewritesResult.resolvedHref) {\n                                    // if this directly matches a page we need to update the href to\n                                    // allow the correct page chunk to be loaded\n                                    pathname = rewritesResult.resolvedHref;\n                                    parsed.pathname = pathname;\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                _state.label = 4;\n                            case 4:\n                                parsed.pathname = resolveDynamicRoute(parsed.pathname, pages);\n                                if ((0, _isdynamic.isDynamicRoute)(parsed.pathname)) {\n                                    pathname = parsed.pathname;\n                                    parsed.pathname = pathname;\n                                    Object.assign(query, (0, _routematcher.getRouteMatcher)((0, _routeregex.getRouteRegex)(parsed.pathname))((0, _parsepath.parsePath)(asPath).pathname) || {});\n                                    if (!isMiddlewareMatch) {\n                                        url = (0, _formaturl.formatWithValidation)(parsed);\n                                    }\n                                }\n                                if (true) return [\n                                    3,\n                                    5\n                                ];\n                                _tmp = null;\n                                return [\n                                    3,\n                                    7\n                                ];\n                            case 5:\n                                return [\n                                    4,\n                                    withMiddlewareEffects({\n                                        fetchData: function() {\n                                            return fetchNextData({\n                                                dataHref: _this.pageLoader.getDataHref({\n                                                    href: (0, _formaturl.formatWithValidation)({\n                                                        pathname: originalPathname,\n                                                        query: query\n                                                    }),\n                                                    skipInterpolation: true,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                hasMiddleware: true,\n                                                isServerRender: _this.isSsr,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true\n                                            });\n                                        },\n                                        asPath: asPath,\n                                        locale: locale,\n                                        router: _this\n                                    })\n                                ];\n                            case 6:\n                                _tmp = _state.sent();\n                                _state.label = 7;\n                            case 7:\n                                data = _tmp;\n                                /**\n     * If there was a rewrite we apply the effects of the rewrite on the\n     * current parameters for the prefetch.\n     */ if ((data == null ? void 0 : data.effect.type) === \"rewrite\") {\n                                    parsed.pathname = data.effect.resolvedHref;\n                                    pathname = data.effect.resolvedHref;\n                                    query = _object_spread._({}, query, data.effect.parsedAs.query);\n                                    resolvedAs = data.effect.parsedAs.pathname;\n                                    url = (0, _formaturl.formatWithValidation)(parsed);\n                                }\n                                /**\n     * If there is a redirect to an external destination then we don't have\n     * to prefetch content as it will be unused.\n     */ if ((data == null ? void 0 : data.effect.type) === \"redirect-external\") {\n                                    return [\n                                        2\n                                    ];\n                                }\n                                route = (0, _removetrailingslash.removeTrailingSlash)(pathname);\n                                return [\n                                    4,\n                                    _this._bfl(asPath, resolvedAs, options.locale, true)\n                                ];\n                            case 8:\n                                if (_state.sent()) {\n                                    _this.components[urlPathname] = {\n                                        __appRouter: true\n                                    };\n                                }\n                                return [\n                                    4,\n                                    Promise.all([\n                                        _this.pageLoader._isSsg(route).then(function(isSsg) {\n                                            return isSsg ? fetchNextData({\n                                                dataHref: (data == null ? void 0 : data.json) ? data == null ? void 0 : data.dataHref : _this.pageLoader.getDataHref({\n                                                    href: url,\n                                                    asPath: resolvedAs,\n                                                    locale: locale\n                                                }),\n                                                isServerRender: false,\n                                                parseJSON: true,\n                                                inflightCache: _this.sdc,\n                                                persistCache: !_this.isPreview,\n                                                isPrefetch: true,\n                                                unstable_skipClientCache: options.unstable_skipClientCache || options.priority && !!true\n                                            }).then(function() {\n                                                return false;\n                                            })[\"catch\"](function() {\n                                                return false;\n                                            }) : false;\n                                        }),\n                                        _this.pageLoader[options.priority ? \"loadPage\" : \"prefetch\"](route)\n                                    ])\n                                ];\n                            case 9:\n                                _state.sent();\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"fetchComponent\",\n            value: function fetchComponent(route) {\n                var _this = this;\n                return _async_to_generator._(function() {\n                    var handleCancelled, componentResult, err;\n                    return _ts_generator._(this, function(_state) {\n                        switch(_state.label){\n                            case 0:\n                                handleCancelled = getCancelledHandler({\n                                    route: route,\n                                    router: _this\n                                });\n                                _state.label = 1;\n                            case 1:\n                                _state.trys.push([\n                                    1,\n                                    3,\n                                    ,\n                                    4\n                                ]);\n                                return [\n                                    4,\n                                    _this.pageLoader.loadPage(route)\n                                ];\n                            case 2:\n                                componentResult = _state.sent();\n                                handleCancelled();\n                                return [\n                                    2,\n                                    componentResult\n                                ];\n                            case 3:\n                                err = _state.sent();\n                                handleCancelled();\n                                throw err;\n                            case 4:\n                                return [\n                                    2\n                                ];\n                        }\n                    });\n                })();\n            }\n        },\n        {\n            key: \"_getData\",\n            value: function _getData(fn) {\n                var _this = this;\n                var cancelled = false;\n                var cancel = function() {\n                    cancelled = true;\n                };\n                this.clc = cancel;\n                return fn().then(function(data) {\n                    if (cancel === _this.clc) {\n                        _this.clc = null;\n                    }\n                    if (cancelled) {\n                        var err = new Error(\"Loading initial props cancelled\");\n                        err.cancelled = true;\n                        throw err;\n                    }\n                    return data;\n                });\n            }\n        },\n        {\n            key: \"_getFlightData\",\n            value: function _getFlightData(dataHref) {\n                // Do not cache RSC flight response since it's not a static resource\n                return fetchNextData({\n                    dataHref: dataHref,\n                    isServerRender: true,\n                    parseJSON: false,\n                    inflightCache: this.sdc,\n                    persistCache: false,\n                    isPrefetch: false\n                }).then(function(param) {\n                    var text = param.text;\n                    return {\n                        data: text\n                    };\n                });\n            }\n        },\n        {\n            key: \"getInitialProps\",\n            value: function getInitialProps(Component, ctx) {\n                var _this_components__app = this.components[\"/_app\"], App = _this_components__app.Component;\n                var AppTree = this._wrapApp(App);\n                ctx.AppTree = AppTree;\n                return (0, _utils.loadGetInitialProps)(App, {\n                    AppTree: AppTree,\n                    Component: Component,\n                    router: this,\n                    ctx: ctx\n                });\n            }\n        },\n        {\n            key: \"route\",\n            get: function get() {\n                return this.state.route;\n            }\n        },\n        {\n            key: \"pathname\",\n            get: function get() {\n                return this.state.pathname;\n            }\n        },\n        {\n            key: \"query\",\n            get: function get() {\n                return this.state.query;\n            }\n        },\n        {\n            key: \"asPath\",\n            get: function get() {\n                return this.state.asPath;\n            }\n        },\n        {\n            key: \"locale\",\n            get: function get() {\n                return this.state.locale;\n            }\n        },\n        {\n            key: \"isFallback\",\n            get: function get() {\n                return this.state.isFallback;\n            }\n        },\n        {\n            key: \"isPreview\",\n            get: function get() {\n                return this.state.isPreview;\n            }\n        }\n    ]);\n    return Router;\n}();\nRouter.events = (0, _mitt[\"default\"])(); //# sourceMappingURL=router.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSw0QkFBNEI7QUFDZjs7Ozs7Ozs7Ozs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0YsS0FBTUMsQ0FBQUEsQ0FJTjtBQUNBLFNBQVNJLFFBQVFDLE1BQU0sRUFBRUMsR0FBRztJQUN4QixJQUFJLElBQUlDLFFBQVFELElBQUlWLE9BQU9DLGNBQWMsQ0FBQ1EsUUFBUUUsTUFBTTtRQUNwREMsWUFBWTtRQUNaQyxLQUFLSCxHQUFHLENBQUNDLEtBQUs7SUFDbEI7QUFDSjtBQUNBSCxRQUFRTixTQUFTO0lBQ2JHLFdBQVMsU0FBVEE7UUFDSSxPQUFPUztJQUNYO0lBQ0FSLG1CQUFtQixTQUFuQkE7UUFDSSxPQUFPQTtJQUNYO0lBQ0FDLFdBQVcsU0FBWEE7UUFDSSxPQUFPQTtJQUNYO0FBQ0o7QUFDQSxJQUFNUSwyQkFBMkJDLG1CQUFPQSxDQUFDLDRHQUF5QztBQUNsRixJQUFNQyw0QkFBNEJELG1CQUFPQSxDQUFDLDhHQUEwQztBQUNwRixJQUFNRSx1QkFBdUJGLG1CQUFPQSxDQUFDLGdIQUErQjtBQUNwRSxJQUFNRyxlQUFlSCxtQkFBT0EsQ0FBQyxxRkFBOEI7QUFDM0QsSUFBTUksVUFBVUosbUJBQU9BLENBQUMseUVBQXdCO0FBQ2hELElBQU1LLFdBQVcsV0FBVyxHQUFHSiwwQkFBMEJLLENBQUMsQ0FBQ04sbUJBQU9BLENBQUMsdUVBQXVCO0FBQzFGLElBQU1PLHVCQUF1QlAsbUJBQU9BLENBQUMsa0hBQW9DO0FBQ3pFLElBQU1RLHVCQUF1QlIsbUJBQU9BLENBQUMsd0dBQStCO0FBQ3BFLElBQU1TLFFBQVEsV0FBVyxHQUFHVix5QkFBeUJPLENBQUMsQ0FBQ04sbUJBQU9BLENBQUMsNERBQVM7QUFDeEUsSUFBTVUsU0FBU1YsbUJBQU9BLENBQUMsOERBQVU7QUFDakMsSUFBTVcsYUFBYVgsbUJBQU9B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QUFPLElBQUksQ0FBQ3FLLEtBQUssQ0FBQ3JLLE1BQU07WUFDNUI7OztZQUNJTSxLQUFBQTtpQkFBSjtnQkFDSSxPQUFPLElBQUksQ0FBQytKLEtBQUssQ0FBQy9KLE1BQU07WUFDNUI7OztZQUNJdUosS0FBQUE7aUJBQUo7Z0JBQ0ksT0FBTyxJQUFJLENBQUNRLEtBQUssQ0FBQ1IsVUFBVTtZQUNoQzs7O1lBQ0lFLEtBQUFBO2lCQUFKO2dCQUNJLE9BQU8sSUFBSSxDQUFDTSxLQUFLLENBQUNOLFNBQVM7WUFDL0I7OztXQXRtQ0VsTjs7QUEreENOQSxPQUFPZ1EsTUFBTSxHQUFHLENBQUMsR0FBR3JQLEtBQU1wQixDQUFBQSxVQUFPLEtBRWpDLGtDQUFrQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L3NoYXJlZC9saWIvcm91dGVyL3JvdXRlci5qcz84Njg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHRzbGludDpkaXNhYmxlOm5vLWNvbnNvbGVcblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZGVmYXVsdDogbnVsbCxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogbnVsbCxcbiAgICBjcmVhdGVLZXk6IG51bGxcbn0pO1xuZnVuY3Rpb24gX2V4cG9ydCh0YXJnZXQsIGFsbCkge1xuICAgIGZvcih2YXIgbmFtZSBpbiBhbGwpT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgbmFtZSwge1xuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBnZXQ6IGFsbFtuYW1lXVxuICAgIH0pO1xufVxuX2V4cG9ydChleHBvcnRzLCB7XG4gICAgZGVmYXVsdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBSb3V0ZXI7XG4gICAgfSxcbiAgICBtYXRjaGVzTWlkZGxld2FyZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYXRjaGVzTWlkZGxld2FyZTtcbiAgICB9LFxuICAgIGNyZWF0ZUtleTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVLZXk7XG4gICAgfVxufSk7XG5jb25zdCBfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQgPSByZXF1aXJlKFwiQHN3Yy9oZWxwZXJzL18vX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0XCIpO1xuY29uc3QgX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkXCIpO1xuY29uc3QgX3JlbW92ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi91dGlscy9yZW1vdmUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBfcm91dGVsb2FkZXIgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JvdXRlLWxvYWRlclwiKTtcbmNvbnN0IF9zY3JpcHQgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3NjcmlwdFwiKTtcbmNvbnN0IF9pc2Vycm9yID0gLyojX19QVVJFX18qLyBfaW50ZXJvcF9yZXF1aXJlX3dpbGRjYXJkLl8ocmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1lcnJvclwiKSk7XG5jb25zdCBfZGVub3JtYWxpemVwYWdlcGF0aCA9IHJlcXVpcmUoXCIuLi9wYWdlLXBhdGgvZGVub3JtYWxpemUtcGFnZS1wYXRoXCIpO1xuY29uc3QgX25vcm1hbGl6ZWxvY2FsZXBhdGggPSByZXF1aXJlKFwiLi4vaTE4bi9ub3JtYWxpemUtbG9jYWxlLXBhdGhcIik7XG5jb25zdCBfbWl0dCA9IC8qI19fUFVSRV9fKi8gX2ludGVyb3BfcmVxdWlyZV9kZWZhdWx0Ll8ocmVxdWlyZShcIi4uL21pdHRcIikpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgX2lzZHluYW1pYyA9IHJlcXVpcmUoXCIuL3V0aWxzL2lzLWR5bmFtaWNcIik7XG5jb25zdCBfcGFyc2VyZWxhdGl2ZXVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL3BhcnNlLXJlbGF0aXZlLXVybFwiKTtcbmNvbnN0IF9yZXNvbHZlcmV3cml0ZXMgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCIuL3V0aWxzL3Jlc29sdmUtcmV3cml0ZXNcIikpO1xuY29uc3QgX3JvdXRlbWF0Y2hlciA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLW1hdGNoZXJcIik7XG5jb25zdCBfcm91dGVyZWdleCA9IHJlcXVpcmUoXCIuL3V0aWxzL3JvdXRlLXJlZ2V4XCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC11cmxcIik7XG5jb25zdCBfZGV0ZWN0ZG9tYWlubG9jYWxlID0gcmVxdWlyZShcIi4uLy4uLy4uL2NsaWVudC9kZXRlY3QtZG9tYWluLWxvY2FsZVwiKTtcbmNvbnN0IF9wYXJzZXBhdGggPSByZXF1aXJlKFwiLi91dGlscy9wYXJzZS1wYXRoXCIpO1xuY29uc3QgX2FkZGxvY2FsZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9jbGllbnQvYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yZW1vdmVsb2NhbGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1sb2NhbGVcIik7XG5jb25zdCBfcmVtb3ZlYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3JlbW92ZS1iYXNlLXBhdGhcIik7XG5jb25zdCBfYWRkYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2FkZC1iYXNlLXBhdGhcIik7XG5jb25zdCBfaGFzYmFzZXBhdGggPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L2hhcy1iYXNlLXBhdGhcIik7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi4vLi4vLi4vY2xpZW50L3Jlc29sdmUtaHJlZlwiKTtcbmNvbnN0IF9pc2FwaXJvdXRlID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9pcy1hcGktcm91dGVcIik7XG5jb25zdCBfZ2V0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2dldC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyA9IHJlcXVpcmUoXCIuL3V0aWxzL2Zvcm1hdC1uZXh0LXBhdGhuYW1lLWluZm9cIik7XG5jb25zdCBfY29tcGFyZXN0YXRlcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2NvbXBhcmUtc3RhdGVzXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi91dGlscy9pcy1sb2NhbC11cmxcIik7XG5jb25zdCBfaXNib3QgPSByZXF1aXJlKFwiLi91dGlscy9pcy1ib3RcIik7XG5jb25zdCBfb21pdCA9IHJlcXVpcmUoXCIuL3V0aWxzL29taXRcIik7XG5jb25zdCBfaW50ZXJwb2xhdGVhcyA9IHJlcXVpcmUoXCIuL3V0aWxzL2ludGVycG9sYXRlLWFzXCIpO1xuY29uc3QgX2hhbmRsZXNtb290aHNjcm9sbCA9IHJlcXVpcmUoXCIuL3V0aWxzL2hhbmRsZS1zbW9vdGgtc2Nyb2xsXCIpO1xuZnVuY3Rpb24gYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoXCJSb3V0ZSBDYW5jZWxsZWRcIiksIHtcbiAgICAgICAgY2FuY2VsbGVkOiB0cnVlXG4gICAgfSk7XG59XG5hc3luYyBmdW5jdGlvbiBtYXRjaGVzTWlkZGxld2FyZShvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcnMgPSBhd2FpdCBQcm9taXNlLnJlc29sdmUob3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRNaWRkbGV3YXJlKCkpO1xuICAgIGlmICghbWF0Y2hlcnMpIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCB7IHBhdGhuYW1lOiBhc1BhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKG9wdGlvbnMuYXNQYXRoKTtcbiAgICAvLyByZW1vdmUgYmFzZVBhdGggZmlyc3Qgc2luY2UgcGF0aCBwcmVmaXggaGFzIHRvIGJlIGluIHRoZSBvcmRlciBvZiBgLyR7YmFzZVBhdGh9LyR7bG9jYWxlfWBcbiAgICBjb25zdCBjbGVhbmVkQXMgPSAoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKShhc1BhdGhuYW1lKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzUGF0aG5hbWUpIDogYXNQYXRobmFtZTtcbiAgICBjb25zdCBhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBvcHRpb25zLmxvY2FsZSkpO1xuICAgIC8vIENoZWNrIG9ubHkgcGF0aCBtYXRjaCBvbiBjbGllbnQuIE1hdGNoaW5nIFwiaGFzXCIgc2hvdWxkIGJlIGRvbmUgb24gc2VydmVyXG4gICAgLy8gd2hlcmUgd2UgY2FuIGFjY2VzcyBtb3JlIGluZm8gc3VjaCBhcyBoZWFkZXJzLCBIdHRwT25seSBjb29raWUsIGV0Yy5cbiAgICByZXR1cm4gbWF0Y2hlcnMuc29tZSgobSk9Pm5ldyBSZWdFeHAobS5yZWdleHApLnRlc3QoYXNXaXRoQmFzZVBhdGhBbmRMb2NhbGUpKTtcbn1cbmZ1bmN0aW9uIHN0cmlwT3JpZ2luKHVybCkge1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgcmV0dXJuIHVybC5zdGFydHNXaXRoKG9yaWdpbikgPyB1cmwuc3Vic3RyaW5nKG9yaWdpbi5sZW5ndGgpIDogdXJsO1xufVxuZnVuY3Rpb24gcHJlcGFyZVVybEFzKHJvdXRlciwgdXJsLCBhcykge1xuICAgIC8vIElmIHVybCBhbmQgYXMgcHJvdmlkZWQgYXMgYW4gb2JqZWN0IHJlcHJlc2VudGF0aW9uLFxuICAgIC8vIHdlJ2xsIGZvcm1hdCB0aGVtIGludG8gdGhlIHN0cmluZyB2ZXJzaW9uIGhlcmUuXG4gICAgbGV0IFtyZXNvbHZlZEhyZWYsIHJlc29sdmVkQXNdID0gKDAsIF9yZXNvbHZlaHJlZi5yZXNvbHZlSHJlZikocm91dGVyLCB1cmwsIHRydWUpO1xuICAgIGNvbnN0IG9yaWdpbiA9ICgwLCBfdXRpbHMuZ2V0TG9jYXRpb25PcmlnaW4pKCk7XG4gICAgY29uc3QgaHJlZldhc0Fic29sdXRlID0gcmVzb2x2ZWRIcmVmLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICBjb25zdCBhc1dhc0Fic29sdXRlID0gcmVzb2x2ZWRBcyAmJiByZXNvbHZlZEFzLnN0YXJ0c1dpdGgob3JpZ2luKTtcbiAgICByZXNvbHZlZEhyZWYgPSBzdHJpcE9yaWdpbihyZXNvbHZlZEhyZWYpO1xuICAgIHJlc29sdmVkQXMgPSByZXNvbHZlZEFzID8gc3RyaXBPcmlnaW4ocmVzb2x2ZWRBcykgOiByZXNvbHZlZEFzO1xuICAgIGNvbnN0IHByZXBhcmVkVXJsID0gaHJlZldhc0Fic29sdXRlID8gcmVzb2x2ZWRIcmVmIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocmVzb2x2ZWRIcmVmKTtcbiAgICBjb25zdCBwcmVwYXJlZEFzID0gYXMgPyBzdHJpcE9yaWdpbigoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShyb3V0ZXIsIGFzKSkgOiByZXNvbHZlZEFzIHx8IHJlc29sdmVkSHJlZjtcbiAgICByZXR1cm4ge1xuICAgICAgICB1cmw6IHByZXBhcmVkVXJsLFxuICAgICAgICBhczogYXNXYXNBYnNvbHV0ZSA/IHByZXBhcmVkQXMgOiAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwcmVwYXJlZEFzKVxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlRHluYW1pY1JvdXRlKHBhdGhuYW1lLCBwYWdlcykge1xuICAgIGNvbnN0IGNsZWFuUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9kZW5vcm1hbGl6ZXBhZ2VwYXRoLmRlbm9ybWFsaXplUGFnZVBhdGgpKHBhdGhuYW1lKSk7XG4gICAgaWYgKGNsZWFuUGF0aG5hbWUgPT09IFwiLzQwNFwiIHx8IGNsZWFuUGF0aG5hbWUgPT09IFwiL19lcnJvclwiKSB7XG4gICAgICAgIHJldHVybiBwYXRobmFtZTtcbiAgICB9XG4gICAgLy8gaGFuZGxlIHJlc29sdmluZyBocmVmIGZvciBkeW5hbWljIHJvdXRlc1xuICAgIGlmICghcGFnZXMuaW5jbHVkZXMoY2xlYW5QYXRobmFtZSkpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGFycmF5LWNhbGxiYWNrLXJldHVyblxuICAgICAgICBwYWdlcy5zb21lKChwYWdlKT0+e1xuICAgICAgICAgICAgaWYgKCgwLCBfaXNkeW5hbWljLmlzRHluYW1pY1JvdXRlKShwYWdlKSAmJiAoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocGFnZSkucmUudGVzdChjbGVhblBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHBhdGhuYW1lID0gcGFnZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0TWlkZGxld2FyZURhdGEoc291cmNlLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgIGNvbnN0IG5leHRDb25maWcgPSB7XG4gICAgICAgIGJhc2VQYXRoOiBvcHRpb25zLnJvdXRlci5iYXNlUGF0aCxcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgbG9jYWxlczogb3B0aW9ucy5yb3V0ZXIubG9jYWxlc1xuICAgICAgICB9LFxuICAgICAgICB0cmFpbGluZ1NsYXNoOiBCb29sZWFuKHByb2Nlc3MuZW52Ll9fTkVYVF9UUkFJTElOR19TTEFTSClcbiAgICB9O1xuICAgIGNvbnN0IHJld3JpdGVIZWFkZXIgPSByZXNwb25zZS5oZWFkZXJzLmdldChcIngtbmV4dGpzLXJld3JpdGVcIik7XG4gICAgbGV0IHJld3JpdGVUYXJnZXQgPSByZXdyaXRlSGVhZGVyIHx8IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KFwieC1uZXh0anMtbWF0Y2hlZC1wYXRoXCIpO1xuICAgIGNvbnN0IG1hdGNoZWRQYXRoID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1hdGNoZWQtcGF0aFwiKTtcbiAgICBpZiAobWF0Y2hlZFBhdGggJiYgIXJld3JpdGVUYXJnZXQgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiX19uZXh0X2RhdGFfY2F0Y2hhbGxcIikgJiYgIW1hdGNoZWRQYXRoLmluY2x1ZGVzKFwiL19lcnJvclwiKSAmJiAhbWF0Y2hlZFBhdGguaW5jbHVkZXMoXCIvNDA0XCIpKSB7XG4gICAgICAgIC8vIGxldmVyYWdlIHgtbWF0Y2hlZC1wYXRoIHRvIGRldGVjdCBuZXh0LmNvbmZpZy5qcyByZXdyaXRlc1xuICAgICAgICByZXdyaXRlVGFyZ2V0ID0gbWF0Y2hlZFBhdGg7XG4gICAgfVxuICAgIGlmIChyZXdyaXRlVGFyZ2V0KSB7XG4gICAgICAgIGlmIChyZXdyaXRlVGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpIHx8IHByb2Nlc3MuZW52Ll9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV3cml0ZVRhcmdldCA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShyZXdyaXRlVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lSW5mbyA9ICgwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICBwYXJzZURhdGE6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IGZzUGF0aG5hbWUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWVJbmZvLnBhdGhuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5yb3V0ZXIucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKVxuICAgICAgICAgICAgXSkudGhlbigocGFyYW0pPT57XG4gICAgICAgICAgICAgICAgbGV0IFtwYWdlcywgeyBfX3Jld3JpdGVzOiByZXdyaXRlcyB9XSA9IHBhcmFtO1xuICAgICAgICAgICAgICAgIGxldCBhcyA9ICgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkocGF0aG5hbWVJbmZvLnBhdGhuYW1lLCBwYXRobmFtZUluZm8ubG9jYWxlKTtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKGFzKSB8fCAhcmV3cml0ZUhlYWRlciAmJiBwYWdlcy5pbmNsdWRlcygoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpLCBvcHRpb25zLnJvdXRlci5sb2NhbGVzKS5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkU291cmNlID0gKDAsIF9nZXRuZXh0cGF0aG5hbWVpbmZvLmdldE5leHRQYXRobmFtZUluZm8pKCgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShzb3VyY2UpLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0Q29uZmlnOiBwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTID8gdW5kZWZpbmVkIDogbmV4dENvbmZpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRTb3VyY2UucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gYXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSEFTX1JFV1JJVEVTKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKGFzLCBwYWdlcywgcmV3cml0ZXMsIHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIChwYXRoKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXRoLCBwYWdlcyksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lm1hdGNoZWRQYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lID0gcmVzdWx0LnBhcnNlZEFzLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgYXMgPSBwYXJzZWRSZXdyaXRlVGFyZ2V0LnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihwYXJzZWRSZXdyaXRlVGFyZ2V0LnF1ZXJ5LCByZXN1bHQucGFyc2VkQXMucXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghcGFnZXMuaW5jbHVkZXMoZnNQYXRobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRQYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUoZnNQYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzb2x2ZWRQYXRobmFtZSAhPT0gZnNQYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnNQYXRobmFtZSA9IHJlc29sdmVkUGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gIXBhZ2VzLmluY2x1ZGVzKGZzUGF0aG5hbWUpID8gcmVzb2x2ZUR5bmFtaWNSb3V0ZSgoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGFyc2VkUmV3cml0ZVRhcmdldC5wYXRobmFtZSksIG9wdGlvbnMucm91dGVyLmxvY2FsZXMpLnBhdGhuYW1lLCBwYWdlcykgOiBmc1BhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocmVzb2x2ZWRIcmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gKDAsIF9yb3V0ZW1hdGNoZXIuZ2V0Um91dGVNYXRjaGVyKSgoMCwgX3JvdXRlcmVnZXguZ2V0Um91dGVSZWdleCkocmVzb2x2ZWRIcmVmKSkoYXMpO1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHBhcnNlZFJld3JpdGVUYXJnZXQucXVlcnksIG1hdGNoZXMgfHwge30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInJld3JpdGVcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkQXM6IHBhcnNlZFJld3JpdGVUYXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVkSHJlZlxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHNvdXJjZSk7XG4gICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgIC4uLigwLCBfZ2V0bmV4dHBhdGhuYW1laW5mby5nZXROZXh0UGF0aG5hbWVJbmZvKShzcmMucGF0aG5hbWUsIHtcbiAgICAgICAgICAgICAgICBuZXh0Q29uZmlnLFxuICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlOiBvcHRpb25zLnJvdXRlci5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7XG4gICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWV4dGVybmFsXCIsXG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHJlZGlyZWN0VGFyZ2V0ID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW5leHRqcy1yZWRpcmVjdFwiKTtcbiAgICBpZiAocmVkaXJlY3RUYXJnZXQpIHtcbiAgICAgICAgaWYgKHJlZGlyZWN0VGFyZ2V0LnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBzcmMgPSAoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKHJlZGlyZWN0VGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhuYW1lID0gKDAsIF9mb3JtYXRuZXh0cGF0aG5hbWVpbmZvLmZvcm1hdE5leHRQYXRobmFtZUluZm8pKHtcbiAgICAgICAgICAgICAgICAuLi4oMCwgX2dldG5leHRwYXRobmFtZWluZm8uZ2V0TmV4dFBhdGhuYW1lSW5mbykoc3JjLnBhdGhuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRDb25maWcsXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlRGF0YTogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IG9wdGlvbnMucm91dGVyLmRlZmF1bHRMb2NhbGUsXG4gICAgICAgICAgICAgICAgYnVpbGRJZDogXCJcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInJlZGlyZWN0LWludGVybmFsXCIsXG4gICAgICAgICAgICAgICAgbmV3QXM6IFwiXCIgKyBwYXRobmFtZSArIHNyYy5xdWVyeSArIHNyYy5oYXNoLFxuICAgICAgICAgICAgICAgIG5ld1VybDogXCJcIiArIHBhdGhuYW1lICsgc3JjLnF1ZXJ5ICsgc3JjLmhhc2hcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoe1xuICAgICAgICAgICAgdHlwZTogXCJyZWRpcmVjdC1leHRlcm5hbFwiLFxuICAgICAgICAgICAgZGVzdGluYXRpb246IHJlZGlyZWN0VGFyZ2V0XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHtcbiAgICAgICAgdHlwZTogXCJuZXh0XCJcbiAgICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHdpdGhNaWRkbGV3YXJlRWZmZWN0cyhvcHRpb25zKSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKG9wdGlvbnMpO1xuICAgIGlmICghbWF0Y2hlcyB8fCAhb3B0aW9ucy5mZXRjaERhdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCBvcHRpb25zLmZldGNoRGF0YSgpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSBhd2FpdCBnZXRNaWRkbGV3YXJlRGF0YShkYXRhLmRhdGFIcmVmLCBkYXRhLnJlc3BvbnNlLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFIcmVmOiBkYXRhLmRhdGFIcmVmLFxuICAgICAgICAgICAganNvbjogZGF0YS5qc29uLFxuICAgICAgICAgICAgcmVzcG9uc2U6IGRhdGEucmVzcG9uc2UsXG4gICAgICAgICAgICB0ZXh0OiBkYXRhLnRleHQsXG4gICAgICAgICAgICBjYWNoZUtleTogZGF0YS5jYWNoZUtleSxcbiAgICAgICAgICAgIGVmZmVjdFxuICAgICAgICB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLyoqXG4gICAgICogVE9ETzogUmV2aXNpdCB0aGlzIGluIHRoZSBmdXR1cmUuXG4gICAgICogRm9yIG5vdyB3ZSB3aWxsIG5vdCBjb25zaWRlciBtaWRkbGV3YXJlIGRhdGEgZXJyb3JzIHRvIGJlIGZhdGFsLlxuICAgICAqIG1heWJlIHdlIHNob3VsZCByZXZpc2l0IGluIHRoZSBmdXR1cmUuXG4gICAgICovIHJldHVybiBudWxsO1xuICAgIH1cbn1cbmNvbnN0IG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uID0gcHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTiAmJiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIFwic2Nyb2xsUmVzdG9yYXRpb25cIiBpbiB3aW5kb3cuaGlzdG9yeSAmJiAhIWZ1bmN0aW9uKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGxldCB2ID0gXCJfX25leHRcIjtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlcXVlbmNlc1xuICAgICAgICByZXR1cm4gc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbSh2LCB2KSwgc2Vzc2lvblN0b3JhZ2UucmVtb3ZlSXRlbSh2KSwgdHJ1ZTtcbiAgICB9IGNhdGNoIChuKSB7fVxufSgpO1xuY29uc3QgU1NHX0RBVEFfTk9UX0ZPVU5EID0gU3ltYm9sKFwiU1NHX0RBVEFfTk9UX0ZPVU5EXCIpO1xuZnVuY3Rpb24gZmV0Y2hSZXRyeSh1cmwsIGF0dGVtcHRzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGZldGNoKHVybCwge1xuICAgICAgICAvLyBDb29raWVzIGFyZSByZXF1aXJlZCB0byBiZSBwcmVzZW50IGZvciBOZXh0LmpzJyBTU0cgXCJQcmV2aWV3IE1vZGVcIi5cbiAgICAgICAgLy8gQ29va2llcyBtYXkgYWxzbyBiZSByZXF1aXJlZCBmb3IgYGdldFNlcnZlclNpZGVQcm9wc2AuXG4gICAgICAgIC8vXG4gICAgICAgIC8vID4gYGZldGNoYCB3b27igJl0IHNlbmQgY29va2llcywgdW5sZXNzIHlvdSBzZXQgdGhlIGNyZWRlbnRpYWxzIGluaXRcbiAgICAgICAgLy8gPiBvcHRpb24uXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GZXRjaF9BUEkvVXNpbmdfRmV0Y2hcbiAgICAgICAgLy9cbiAgICAgICAgLy8gPiBGb3IgbWF4aW11bSBicm93c2VyIGNvbXBhdGliaWxpdHkgd2hlbiBpdCBjb21lcyB0byBzZW5kaW5nICZcbiAgICAgICAgLy8gPiByZWNlaXZpbmcgY29va2llcywgYWx3YXlzIHN1cHBseSB0aGUgYGNyZWRlbnRpYWxzOiAnc2FtZS1vcmlnaW4nYFxuICAgICAgICAvLyA+IG9wdGlvbiBpbnN0ZWFkIG9mIHJlbHlpbmcgb24gdGhlIGRlZmF1bHQuXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9naXRodWIvZmV0Y2gjY2F2ZWF0c1xuICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiLFxuICAgICAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kIHx8IFwiR0VUXCIsXG4gICAgICAgIGhlYWRlcnM6IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuaGVhZGVycywge1xuICAgICAgICAgICAgXCJ4LW5leHRqcy1kYXRhXCI6IFwiMVwiXG4gICAgICAgIH0pXG4gICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgIHJldHVybiAhcmVzcG9uc2Uub2sgJiYgYXR0ZW1wdHMgPiAxICYmIHJlc3BvbnNlLnN0YXR1cyA+PSA1MDAgPyBmZXRjaFJldHJ5KHVybCwgYXR0ZW1wdHMgLSAxLCBvcHRpb25zKSA6IHJlc3BvbnNlO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gdHJ5VG9QYXJzZUFzSlNPTih0ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UodGV4dCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuZnVuY3Rpb24gZmV0Y2hOZXh0RGF0YShwYXJhbSkge1xuICAgIGxldCB7IGRhdGFIcmVmLCBpbmZsaWdodENhY2hlLCBpc1ByZWZldGNoLCBoYXNNaWRkbGV3YXJlLCBpc1NlcnZlclJlbmRlciwgcGFyc2VKU09OLCBwZXJzaXN0Q2FjaGUsIGlzQmFja2dyb3VuZCwgdW5zdGFibGVfc2tpcENsaWVudENhY2hlIH0gPSBwYXJhbTtcbiAgICBjb25zdCB7IGhyZWY6IGNhY2hlS2V5IH0gPSBuZXcgVVJMKGRhdGFIcmVmLCB3aW5kb3cubG9jYXRpb24uaHJlZik7XG4gICAgdmFyIF9wYXJhbXNfbWV0aG9kO1xuICAgIGNvbnN0IGdldERhdGEgPSAocGFyYW1zKT0+ZmV0Y2hSZXRyeShkYXRhSHJlZiwgaXNTZXJ2ZXJSZW5kZXIgPyAzIDogMSwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgaXNQcmVmZXRjaCA/IHtcbiAgICAgICAgICAgICAgICBwdXJwb3NlOiBcInByZWZldGNoXCJcbiAgICAgICAgICAgIH0gOiB7fSwgaXNQcmVmZXRjaCAmJiBoYXNNaWRkbGV3YXJlID8ge1xuICAgICAgICAgICAgICAgIFwieC1taWRkbGV3YXJlLXByZWZldGNoXCI6IFwiMVwiXG4gICAgICAgICAgICB9IDoge30pLFxuICAgICAgICAgICAgbWV0aG9kOiAoX3BhcmFtc19tZXRob2QgPSBwYXJhbXMgPT0gbnVsbCA/IHZvaWQgMCA6IHBhcmFtcy5tZXRob2QpICE9IG51bGwgPyBfcGFyYW1zX21ldGhvZCA6IFwiR0VUXCJcbiAgICAgICAgfSkudGhlbigocmVzcG9uc2UpPT57XG4gICAgICAgICAgICBpZiAocmVzcG9uc2Uub2sgJiYgKHBhcmFtcyA9PSBudWxsID8gdm9pZCAwIDogcGFyYW1zLm1ldGhvZCkgPT09IFwiSEVBRFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVLZXlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnRleHQoKS50aGVuKCh0ZXh0KT0+e1xuICAgICAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXaGVuIHRoZSBkYXRhIHJlc3BvbnNlIGlzIGEgcmVkaXJlY3QgYmVjYXVzZSBvZiBhIG1pZGRsZXdhcmVcbiAgICAgICAgICAgICAqIHdlIGRvIG5vdCBjb25zaWRlciBpdCBhbiBlcnJvci4gVGhlIGhlYWRlcnMgbXVzdCBicmluZyB0aGVcbiAgICAgICAgICAgICAqIG1hcHBlZCBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIFRPRE86IENoYW5nZSB0aGUgc3RhdHVzIGNvZGUgaW4gdGhlIGhhbmRsZXIuXG4gICAgICAgICAgICAgKi8gaWYgKGhhc01pZGRsZXdhcmUgJiYgW1xuICAgICAgICAgICAgICAgICAgICAgICAgMzAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzAyLFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA3LFxuICAgICAgICAgICAgICAgICAgICAgICAgMzA4XG4gICAgICAgICAgICAgICAgICAgIF0uaW5jbHVkZXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb246IHt9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF90cnlUb1BhcnNlQXNKU09OO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChfdHJ5VG9QYXJzZUFzSlNPTiA9IHRyeVRvUGFyc2VBc0pTT04odGV4dCkpID09IG51bGwgPyB2b2lkIDAgOiBfdHJ5VG9QYXJzZUFzSlNPTi5ub3RGb3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZDogU1NHX0RBVEFfTk9UX0ZPVU5EXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gbG9hZCBzdGF0aWMgcHJvcHNcIik7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV2Ugc2hvdWxkIG9ubHkgdHJpZ2dlciBhIHNlcnZlci1zaWRlIHRyYW5zaXRpb24gaWYgdGhpcyB3YXNcbiAgICAgICAgICAgICAqIGNhdXNlZCBvbiBhIGNsaWVudC1zaWRlIHRyYW5zaXRpb24uIE90aGVyd2lzZSwgd2UnZCBnZXQgaW50b1xuICAgICAgICAgICAgICogYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgICAgICAqLyBpZiAoIWlzU2VydmVyUmVuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgX3JvdXRlbG9hZGVyLm1hcmtBc3NldEVycm9yKShlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFIcmVmLFxuICAgICAgICAgICAgICAgICAgICBqc29uOiBwYXJzZUpTT04gPyB0cnlUb1BhcnNlQXNKU09OKHRleHQpIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KS50aGVuKChkYXRhKT0+e1xuICAgICAgICAgICAgaWYgKCFwZXJzaXN0Q2FjaGUgfHwgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiIHx8IGRhdGEucmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtY2FjaGVcIikgPT09IFwibm8tY2FjaGVcIikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbmZsaWdodENhY2hlW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KS5jYXRjaCgoZXJyKT0+e1xuICAgICAgICAgICAgaWYgKCF1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaW5mbGlnaHRDYWNoZVtjYWNoZUtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoLy8gY2hyb21lXG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJGYWlsZWQgdG8gZmV0Y2hcIiB8fCAvLyBmaXJlZm94XG4gICAgICAgICAgICBlcnIubWVzc2FnZSA9PT0gXCJOZXR3b3JrRXJyb3Igd2hlbiBhdHRlbXB0aW5nIHRvIGZldGNoIHJlc291cmNlLlwiIHx8IC8vIHNhZmFyaVxuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPT09IFwiTG9hZCBmYWlsZWRcIikge1xuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIubWFya0Fzc2V0RXJyb3IpKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH0pO1xuICAgIC8vIHdoZW4gc2tpcHBpbmcgY2xpZW50IGNhY2hlIHdlIHdhaXQgdG8gdXBkYXRlXG4gICAgLy8gaW5mbGlnaHQgY2FjaGUgdW50aWwgc3VjY2Vzc2Z1bCBkYXRhIHJlc3BvbnNlXG4gICAgLy8gdGhpcyBhbGxvd3MgcmFjaW5nIGNsaWNrIGV2ZW50IHdpdGggZmV0Y2hpbmcgbmV3ZXIgZGF0YVxuICAgIC8vIHdpdGhvdXQgYmxvY2tpbmcgbmF2aWdhdGlvbiB3aGVuIHN0YWxlIGRhdGEgaXMgYXZhaWxhYmxlXG4gICAgaWYgKHVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSAmJiBwZXJzaXN0Q2FjaGUpIHtcbiAgICAgICAgcmV0dXJuIGdldERhdGEoe30pLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpbmZsaWdodENhY2hlW2NhY2hlS2V5XSA9IFByb21pc2UucmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGluZmxpZ2h0Q2FjaGVbY2FjaGVLZXldO1xuICAgIH1cbiAgICByZXR1cm4gaW5mbGlnaHRDYWNoZVtjYWNoZUtleV0gPSBnZXREYXRhKGlzQmFja2dyb3VuZCA/IHtcbiAgICAgICAgbWV0aG9kOiBcIkhFQURcIlxuICAgIH0gOiB7fSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXkoKSB7XG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIsIDEwKTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHBhcmFtKSB7XG4gICAgbGV0IHsgdXJsLCByb3V0ZXIgfSA9IHBhcmFtO1xuICAgIC8vIGVuc3VyZSB3ZSBkb24ndCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uIHRvIHRoZSBzYW1lXG4gICAgLy8gVVJMIGFzIHRoaXMgY2FuIGVuZCB1cCB3aXRoIGFuIGluZmluaXRlIHJlZnJlc2hcbiAgICBpZiAodXJsID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKHJvdXRlci5hc1BhdGgsIHJvdXRlci5sb2NhbGUpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBoYXJkIG5hdmlnYXRlIHRvIHRoZSBzYW1lIFVSTCBcIiArIHVybCArIFwiIFwiICsgbG9jYXRpb24uaHJlZik7XG4gICAgfVxuICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xufVxuY29uc3QgZ2V0Q2FuY2VsbGVkSGFuZGxlciA9IChwYXJhbSk9PntcbiAgICBsZXQgeyByb3V0ZSwgcm91dGVyIH0gPSBwYXJhbTtcbiAgICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gICAgY29uc3QgY2FuY2VsID0gcm91dGVyLmNsYyA9ICgpPT57XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVDYW5jZWxsZWQgPSAoKT0+e1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcignQWJvcnQgZmV0Y2hpbmcgY29tcG9uZW50IGZvciByb3V0ZTogXCInICsgcm91dGUgKyAnXCInKTtcbiAgICAgICAgICAgIGVycm9yLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FuY2VsID09PSByb3V0ZXIuY2xjKSB7XG4gICAgICAgICAgICByb3V0ZXIuY2xjID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGhhbmRsZUNhbmNlbGxlZDtcbn07XG5jbGFzcyBSb3V0ZXIge1xuICAgIHJlbG9hZCgpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICogR28gYmFjayBpbiBoaXN0b3J5XG4gICAqLyBiYWNrKCkge1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5iYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBHbyBmb3J3YXJkIGluIGhpc3RvcnlcbiAgICovIGZvcndhcmQoKSB7XG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LmZvcndhcmQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAqIFBlcmZvcm1zIGEgYHB1c2hTdGF0ZWAgd2l0aCBhcmd1bWVudHNcbiAgICogQHBhcmFtIHVybCBvZiB0aGUgcm91dGVcbiAgICogQHBhcmFtIGFzIG1hc2tzIGB1cmxgIGZvciB0aGUgYnJvd3NlclxuICAgKiBAcGFyYW0gb3B0aW9ucyBvYmplY3QgeW91IGNhbiBkZWZpbmUgYHNoYWxsb3dgIGFuZCBvdGhlciBvcHRpb25zXG4gICAqLyBwdXNoKHVybCwgYXMsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVtb3ZlIGluIHRoZSBmdXR1cmUgd2hlbiB3ZSB1cGRhdGUgaGlzdG9yeSBiZWZvcmUgcm91dGUgY2hhbmdlXG4gICAgICAgICAgICAvLyBpcyBjb21wbGV0ZSwgYXMgdGhlIHBvcHN0YXRlIGV2ZW50IHNob3VsZCBoYW5kbGUgdGhpcyBjYXB0dXJlLlxuICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU25hcHNob3Qgc2Nyb2xsIHBvc2l0aW9uIHJpZ2h0IGJlZm9yZSBuYXZpZ2F0aW5nIHRvIGEgbmV3IHBhZ2U6XG4gICAgICAgICAgICAgICAgICAgIHNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsgdGhpcy5fa2V5LCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogc2VsZi5wYWdlWU9mZnNldFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAoeyB1cmwsIGFzIH0gPSBwcmVwYXJlVXJsQXModGhpcywgdXJsLCBhcykpO1xuICAgICAgICByZXR1cm4gdGhpcy5jaGFuZ2UoXCJwdXNoU3RhdGVcIiwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQZXJmb3JtcyBhIGByZXBsYWNlU3RhdGVgIHdpdGggYXJndW1lbnRzXG4gICAqIEBwYXJhbSB1cmwgb2YgdGhlIHJvdXRlXG4gICAqIEBwYXJhbSBhcyBtYXNrcyBgdXJsYCBmb3IgdGhlIGJyb3dzZXJcbiAgICogQHBhcmFtIG9wdGlvbnMgb2JqZWN0IHlvdSBjYW4gZGVmaW5lIGBzaGFsbG93YCBhbmQgb3RoZXIgb3B0aW9uc1xuICAgKi8gcmVwbGFjZSh1cmwsIGFzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgKHsgdXJsLCBhcyB9ID0gcHJlcGFyZVVybEFzKHRoaXMsIHVybCwgYXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKFwicmVwbGFjZVN0YXRlXCIsIHVybCwgYXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBhc3luYyBfYmZsKGFzLCByZXNvbHZlZEFzLCBsb2NhbGUsIHNraXBOYXZpZ2F0ZSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfRklMVEVSX0VOQUJMRUQpIHtcbiAgICAgICAgICAgIGxldCBtYXRjaGVzQmZsU3RhdGljID0gZmFsc2U7XG4gICAgICAgICAgICBsZXQgbWF0Y2hlc0JmbER5bmFtaWMgPSBmYWxzZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3VyQXMgb2YgW1xuICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgIHJlc29sdmVkQXNcbiAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgIGlmIChjdXJBcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vU2xhc2ggPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkobmV3IFVSTChjdXJBcywgXCJodHRwOi8vblwiKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzTm9TbGFzaExvY2FsZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoYXNOb1NsYXNoLCBsb2NhbGUgfHwgdGhpcy5sb2NhbGUpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzTm9TbGFzaCAhPT0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKG5ldyBVUkwodGhpcy5hc1BhdGgsIFwiaHR0cDovL25cIikucGF0aG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9zLCBfdGhpc19fYmZsX3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlc0JmbFN0YXRpYyA9IG1hdGNoZXNCZmxTdGF0aWMgfHwgISEoKF90aGlzX19iZmxfcyA9IHRoaXMuX2JmbF9zKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9zLmNvbnRhaW5zKGFzTm9TbGFzaCkpIHx8ICEhKChfdGhpc19fYmZsX3MxID0gdGhpcy5fYmZsX3MpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpc19fYmZsX3MxLmNvbnRhaW5zKGFzTm9TbGFzaExvY2FsZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBub3JtYWxpemVkQVMgb2YgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzTm9TbGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc05vU2xhc2hMb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGFueSBzdWItcGF0aCBvZiBhcyBtYXRjaGVzIGEgZHluYW1pYyBmaWx0ZXIgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IHNob3VsZCBiZSBoYXJkIG5hdmlnYXRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1ckFzUGFydHMgPSBub3JtYWxpemVkQVMuc3BsaXQoXCIvXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcihsZXQgaSA9IDA7ICFtYXRjaGVzQmZsRHluYW1pYyAmJiBpIDwgY3VyQXNQYXJ0cy5sZW5ndGggKyAxOyBpKyspe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXNfX2JmbF9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGFydCA9IGN1ckFzUGFydHMuc2xpY2UoMCwgaSkuam9pbihcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGFydCAmJiAoKF90aGlzX19iZmxfZCA9IHRoaXMuX2JmbF9kKSA9PSBudWxsID8gdm9pZCAwIDogX3RoaXNfX2JmbF9kLmNvbnRhaW5zKGN1cnJlbnRQYXJ0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXNCZmxEeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIGNsaWVudCByb3V0ZXIgZmlsdGVyIGlzIG1hdGNoZWQgdGhlbiB3ZSB0cmlnZ2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhIGhhcmQgbmF2aWdhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNCZmxTdGF0aWMgfHwgbWF0Y2hlc0JmbER5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2tpcE5hdmlnYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShhcywgbG9jYWxlIHx8IHRoaXMubG9jYWxlLCB0aGlzLmRlZmF1bHRMb2NhbGUpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhc3luYyBjaGFuZ2UobWV0aG9kLCB1cmwsIGFzLCBvcHRpb25zLCBmb3JjZWRTY3JvbGwpIHtcbiAgICAgICAgdmFyIF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWU7XG4gICAgICAgIGlmICghKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKHVybCkpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXQVJOSU5HOiBgX2hgIGlzIGFuIGludGVybmFsIG9wdGlvbiBmb3IgaGFuZGluZyBOZXh0LmpzIGNsaWVudC1zaWRlXG4gICAgICAgIC8vIGh5ZHJhdGlvbi4gWW91ciBhcHAgc2hvdWxkIF9uZXZlcl8gdXNlIHRoaXMgcHJvcGVydHkuIEl0IG1heSBjaGFuZ2UgYXRcbiAgICAgICAgLy8gYW55IHRpbWUgd2l0aG91dCBub3RpY2UuXG4gICAgICAgIGNvbnN0IGlzUXVlcnlVcGRhdGluZyA9IG9wdGlvbnMuX2ggPT09IDE7XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nICYmICFvcHRpb25zLnNoYWxsb3cpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgdW5kZWZpbmVkLCBvcHRpb25zLmxvY2FsZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNob3VsZFJlc29sdmVIcmVmID0gaXNRdWVyeVVwZGF0aW5nIHx8IG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmIHx8ICgwLCBfcGFyc2VwYXRoLnBhcnNlUGF0aCkodXJsKS5wYXRobmFtZSA9PT0gKDAsIF9wYXJzZXBhdGgucGFyc2VQYXRoKShhcykucGF0aG5hbWU7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLnRoaXMuc3RhdGVcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yIHN0YXRpYyBwYWdlcyB3aXRoIHF1ZXJ5IHBhcmFtcyBpbiB0aGUgVVJMIHdlIGRlbGF5XG4gICAgICAgIC8vIG1hcmtpbmcgdGhlIHJvdXRlciByZWFkeSB1bnRpbCBhZnRlciB0aGUgcXVlcnkgaXMgdXBkYXRlZFxuICAgICAgICAvLyBvciBhIG5hdmlnYXRpb24gaGFzIG9jY3VycmVkXG4gICAgICAgIGNvbnN0IHJlYWR5U3RhdGVDaGFuZ2UgPSB0aGlzLmlzUmVhZHkgIT09IHRydWU7XG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XG4gICAgICAgIGNvbnN0IGlzU3NyID0gdGhpcy5pc1NzcjtcbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTc3IgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhIHJvdXRlIHRyYW5zaXRpb24gaXMgYWxyZWFkeSBpbiBwcm9ncmVzcyBiZWZvcmVcbiAgICAgICAgLy8gdGhlIHF1ZXJ5IHVwZGF0aW5nIGlzIHRyaWdnZXJlZCBpZ25vcmUgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZyAmJiB0aGlzLmNsYykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZMb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IG9wdGlvbnMubG9jYWxlID09PSBmYWxzZSA/IHRoaXMuZGVmYXVsdExvY2FsZSA6IG9wdGlvbnMubG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMubG9jYWxlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgIGlmIChsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgbmV4dFN0YXRlLmxvY2FsZSA9IGxvY2FsZVBhdGhSZXN1bHQuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgICAgICAgICAgcGFyc2VkQXMucGF0aG5hbWUgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKShwYXJzZWRBcy5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgYXMgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKSgoMCwgX2hhc2Jhc2VwYXRoLmhhc0Jhc2VQYXRoKSh1cmwpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkodXJsKSA6IHVybCwgdGhpcy5sb2NhbGVzKS5wYXRobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZGlkTmF2aWdhdGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gd3JhcCB0aGlzIGluIHRoZSBlbnYgY2hlY2sgYWdhaW4gc2luY2UgcmVnZW5lcmF0b3IgcnVudGltZVxuICAgICAgICAgICAgLy8gbW92ZXMgdGhpcyBvbiBpdHMgb3duIGR1ZSB0byB0aGUgcmV0dXJuXG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpc19sb2NhbGVzO1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBsb2NhbGUgaXNuJ3QgY29uZmlndXJlZCBoYXJkIG5hdmlnYXRlIHRvIHNob3cgNDA0IHBhZ2VcbiAgICAgICAgICAgICAgICBpZiAoISgoX3RoaXNfbG9jYWxlcyA9IHRoaXMubG9jYWxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2xvY2FsZXMuaW5jbHVkZXMobmV4dFN0YXRlLmxvY2FsZSkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZEFzLnBhdGhuYW1lID0gKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShwYXJzZWRBcy5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZEFzKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRldGVjdGVkRG9tYWluID0gKDAsIF9kZXRlY3Rkb21haW5sb2NhbGUuZGV0ZWN0RG9tYWluTG9jYWxlKSh0aGlzLmRvbWFpbkxvY2FsZXMsIHVuZGVmaW5lZCwgbmV4dFN0YXRlLmxvY2FsZSk7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdyYXAgdGhpcyBpbiB0aGUgZW52IGNoZWNrIGFnYWluIHNpbmNlIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgIC8vIG1vdmVzIHRoaXMgb24gaXRzIG93biBkdWUgdG8gdGhlIHJldHVyblxuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhcmUgbmF2aWdhdGluZyB0byBhIGRvbWFpbiBsb2NhbGUgZW5zdXJlIHdlIHJlZGlyZWN0IHRvIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvcnJlY3QgZG9tYWluXG4gICAgICAgICAgICAgICAgaWYgKCFkaWROYXZpZ2F0ZSAmJiBkZXRlY3RlZERvbWFpbiAmJiB0aGlzLmlzTG9jYWxlRG9tYWluICYmIHNlbGYubG9jYXRpb24uaG9zdG5hbWUgIT09IGRldGVjdGVkRG9tYWluLmRvbWFpbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhc05vQmFzZVBhdGggPSAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShhcyk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogXCJodHRwXCIgKyAoZGV0ZWN0ZWREb21haW4uaHR0cCA/IFwiXCIgOiBcInNcIikgKyBcIjovL1wiICsgZGV0ZWN0ZWREb21haW4uZG9tYWluICsgKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoXCJcIiArIChuZXh0U3RhdGUubG9jYWxlID09PSBkZXRlY3RlZERvbWFpbi5kZWZhdWx0TG9jYWxlID8gXCJcIiA6IFwiL1wiICsgbmV4dFN0YXRlLmxvY2FsZSkgKyAoYXNOb0Jhc2VQYXRoID09PSBcIi9cIiA/IFwiXCIgOiBhc05vQmFzZVBhdGgpIHx8IFwiL1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3YXMgcHJldmlvdXNseSBhIHJldHVybiBidXQgd2FzIHJlbW92ZWQgaW4gZmF2b3JcbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgYmV0dGVyIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3aXRoIHJlZ2VuZXJhdG9yIHJ1bnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGlkTmF2aWdhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaWROYXZpZ2F0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIG1hcmtpbmcgcm91dGUgY2hhbmdlcyBhcyBhIG5hdmlnYXRpb24gc3RhcnQgZW50cnlcbiAgICAgICAgaWYgKF91dGlscy5TVCkge1xuICAgICAgICAgICAgcGVyZm9ybWFuY2UubWFyayhcInJvdXRlQ2hhbmdlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2hhbGxvdyA9IGZhbHNlLCBzY3JvbGwgPSB0cnVlIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCByb3V0ZVByb3BzID0ge1xuICAgICAgICAgICAgc2hhbGxvd1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5faW5GbGlnaHRSb3V0ZSAmJiB0aGlzLmNsYykge1xuICAgICAgICAgICAgaWYgKCFpc1Nzcikge1xuICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlRXJyb3JcIiwgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpLCB0aGlzLl9pbkZsaWdodFJvdXRlLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xjKCk7XG4gICAgICAgICAgICB0aGlzLmNsYyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgYXMgPSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKGFzKSA/ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKGFzKSA6IGFzLCBvcHRpb25zLmxvY2FsZSwgdGhpcy5kZWZhdWx0TG9jYWxlKSk7XG4gICAgICAgIGNvbnN0IGNsZWFuZWRBcyA9ICgwLCBfcmVtb3ZlbG9jYWxlLnJlbW92ZUxvY2FsZSkoKDAsIF9oYXNiYXNlcGF0aC5oYXNCYXNlUGF0aCkoYXMpID8gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoYXMpIDogYXMsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICB0aGlzLl9pbkZsaWdodFJvdXRlID0gYXM7XG4gICAgICAgIGNvbnN0IGxvY2FsZUNoYW5nZSA9IHByZXZMb2NhbGUgIT09IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgIC8vIElmIHRoZSB1cmwgY2hhbmdlIGlzIG9ubHkgcmVsYXRlZCB0byBhIGhhc2ggY2hhbmdlXG4gICAgICAgIC8vIFdlIHNob3VsZCBub3QgcHJvY2VlZC4gV2Ugc2hvdWxkIG9ubHkgY2hhbmdlIHRoZSBzdGF0ZS5cbiAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgdGhpcy5vbmx5QUhhc2hDaGFuZ2UoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBuZXh0U3RhdGUuYXNQYXRoID0gY2xlYW5lZEFzO1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiaGFzaENoYW5nZVN0YXJ0XCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IGRvIHdlIG5lZWQgdGhlIHJlc29sdmVkIGhyZWYgd2hlbiBvbmx5IGEgaGFzaCBjaGFuZ2U/XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goY2xlYW5lZEFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQobmV4dFN0YXRlLCB0aGlzLmNvbXBvbmVudHNbbmV4dFN0YXRlLnJvdXRlXSwgbnVsbCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKGVycikgJiYgZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiaGFzaENoYW5nZUNvbXBsZXRlXCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgbGV0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSBwYXJzZWQ7XG4gICAgICAgIC8vIGlmIHdlIGRldGVjdGVkIHRoZSBwYXRoIGFzIGFwcCByb3V0ZSBkdXJpbmcgcHJlZmV0Y2hpbmdcbiAgICAgICAgLy8gdHJpZ2dlciBoYXJkIG5hdmlnYXRpb25cbiAgICAgICAgaWYgKChfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lID0gdGhpcy5jb21wb25lbnRzW3BhdGhuYW1lXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzX2NvbXBvbmVudHNfcGF0aG5hbWUuX19hcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKCk9Pnt9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgYnVpbGQgbWFuaWZlc3QgbmVlZHMgdG8gYmUgbG9hZGVkIGJlZm9yZSBhdXRvLXN0YXRpYyBkeW5hbWljIHBhZ2VzXG4gICAgICAgIC8vIGdldCB0aGVpciBxdWVyeSBwYXJhbWV0ZXJzIHRvIGFsbG93IGVuc3VyaW5nIHRoZXkgY2FuIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgICAgICAvLyB3aGVuIHJld3JpdHRlbiB0b1xuICAgICAgICBsZXQgcGFnZXMsIHJld3JpdGVzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW3BhZ2VzLCB7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH1dID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMucGFnZUxvYWRlci5nZXRQYWdlTGlzdCgpLFxuICAgICAgICAgICAgICAgICgwLCBfcm91dGVsb2FkZXIuZ2V0Q2xpZW50QnVpbGRNYW5pZmVzdCkoKSxcbiAgICAgICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuZ2V0TWlkZGxld2FyZSgpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHJlc29sdmUgdGhlIHBhZ2UgbGlzdCBvciBjbGllbnQtYnVpbGQgbWFuaWZlc3QsIHdlIG11c3RcbiAgICAgICAgICAgIC8vIGRvIGEgc2VydmVyLXNpZGUgdHJhbnNpdGlvbjpcbiAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgYXNrZWQgdG8gY2hhbmdlIHRoZSBjdXJyZW50IFVSTCB3ZSBzaG91bGQgcmVsb2FkIHRoZSBjdXJyZW50IHBhZ2VcbiAgICAgICAgLy8gKG5vdCBsb2NhdGlvbi5yZWxvYWQoKSBidXQgcmVsb2FkIGdldEluaXRpYWxQcm9wcyBhbmQgb3RoZXIgTmV4dC5qcyBzdHVmZnMpXG4gICAgICAgIC8vIFdlIGFsc28gbmVlZCB0byBzZXQgdGhlIG1ldGhvZCA9IHJlcGxhY2VTdGF0ZSBhbHdheXNcbiAgICAgICAgLy8gYXMgdGhpcyBzaG91bGQgbm90IGdvIGludG8gdGhlIGhpc3RvcnkgKFRoYXQncyBob3cgYnJvd3NlcnMgd29yaylcbiAgICAgICAgLy8gV2Ugc2hvdWxkIGNvbXBhcmUgdGhlIG5ldyBhc1BhdGggdG8gdGhlIGN1cnJlbnQgYXNQYXRoLCBub3QgdGhlIHVybFxuICAgICAgICBpZiAoIXRoaXMudXJsSXNOZXcoY2xlYW5lZEFzKSAmJiAhbG9jYWxlQ2hhbmdlKSB7XG4gICAgICAgICAgICBtZXRob2QgPSBcInJlcGxhY2VTdGF0ZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVzb2x2ZSB0aGUgYXMgdmFsdWUgdXNpbmcgcmV3cml0ZXMgZm9yIGR5bmFtaWMgU1NHXG4gICAgICAgIC8vIHBhZ2VzIHRvIGFsbG93IGJ1aWxkaW5nIHRoZSBkYXRhIFVSTCBjb3JyZWN0bHlcbiAgICAgICAgbGV0IHJlc29sdmVkQXMgPSBhcztcbiAgICAgICAgLy8gdXJsIGFuZCBhcyBzaG91bGQgYWx3YXlzIGJlIHByZWZpeGVkIHdpdGggYmFzZVBhdGggYnkgdGhpc1xuICAgICAgICAvLyBwb2ludCBieSBlaXRoZXIgbmV4dC9saW5rIG9yIHJvdXRlci5wdXNoL3JlcGxhY2Ugc28gc3RyaXAgdGhlXG4gICAgICAgIC8vIGJhc2VQYXRoIGZyb20gdGhlIHBhdGhuYW1lIHRvIG1hdGNoIHRoZSBwYWdlcyBkaXIgMS10by0xXG4gICAgICAgIHBhdGhuYW1lID0gcGF0aG5hbWUgPyAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkoKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkocGF0aG5hbWUpKSA6IHBhdGhuYW1lO1xuICAgICAgICBsZXQgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBjb25zdCBwYXJzZWRBc1BhdGhuYW1lID0gYXMuc3RhcnRzV2l0aChcIi9cIikgJiYgKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzKS5wYXRobmFtZTtcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlUmV3cml0ZSA9ICEhKHBhcnNlZEFzUGF0aG5hbWUgJiYgcm91dGUgIT09IHBhcnNlZEFzUGF0aG5hbWUgJiYgKCEoMCwgX2lzZHluYW1pYy5pc0R5bmFtaWNSb3V0ZSkocm91dGUpIHx8ICEoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShyb3V0ZSkpKHBhcnNlZEFzUGF0aG5hbWUpKSk7XG4gICAgICAgIC8vIHdlIGRvbid0IGF0dGVtcHQgcmVzb2x2ZSBhc1BhdGggd2hlbiB3ZSBuZWVkIHRvIGV4ZWN1dGVcbiAgICAgICAgLy8gbWlkZGxld2FyZSBhcyB0aGUgcmVzb2x2aW5nIHdpbGwgb2NjdXIgc2VydmVyLXNpZGVcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSAhb3B0aW9ucy5zaGFsbG93ICYmIGF3YWl0IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIGFzUGF0aDogYXMsXG4gICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcgJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgIHNob3VsZFJlc29sdmVIcmVmID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFJlc29sdmVIcmVmICYmIHBhdGhuYW1lICE9PSBcIi9fZXJyb3JcIikge1xuICAgICAgICAgICAgb3B0aW9ucy5fc2hvdWxkUmVzb2x2ZUhyZWYgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMgJiYgYXMuc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXdyaXRlc1Jlc3VsdCA9ICgwLCBfcmVzb2x2ZXJld3JpdGVzLmRlZmF1bHQpKCgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKCgwLCBfYWRkbG9jYWxlLmFkZExvY2FsZSkoY2xlYW5lZEFzLCBuZXh0U3RhdGUubG9jYWxlKSwgdHJ1ZSksIHBhZ2VzLCByZXdyaXRlcywgcXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgaWYgKHJld3JpdGVzUmVzdWx0LmV4dGVybmFsRGVzdCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IGFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gcmV3cml0ZXNSZXN1bHQuYXNQYXRoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQubWF0Y2hlZFBhZ2UgJiYgcmV3cml0ZXNSZXN1bHQucmVzb2x2ZWRIcmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlyZWN0bHkgbWF0Y2hlcyBhIHBhZ2Ugd2UgbmVlZCB0byB1cGRhdGUgdGhlIGhyZWYgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IHJlc29sdmVEeW5hbWljUm91dGUocGF0aG5hbWUsIHBhZ2VzKTtcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkLnBhdGhuYW1lICE9PSBwYXRobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHBhcnNlZC5wYXRobmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkocGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShhcykpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaHJlZjogXCInICsgdXJsICsgJ1wiIGFuZCBhczogXCInICsgYXMgKyAnXCIsIHJlY2VpdmVkIHJlbGF0aXZlIGhyZWYgYW5kIGV4dGVybmFsIGFzJyArIFwiXFxuU2VlIG1vcmUgaW5mbzogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1yZWxhdGl2ZS11cmwtZXh0ZXJuYWwtYXNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJlc29sdmVkQXMpLCBuZXh0U3RhdGUubG9jYWxlKTtcbiAgICAgICAgcm91dGUgPSAoMCwgX3JlbW92ZXRyYWlsaW5nc2xhc2gucmVtb3ZlVHJhaWxpbmdTbGFzaCkocGF0aG5hbWUpO1xuICAgICAgICBsZXQgcm91dGVNYXRjaCA9IGZhbHNlO1xuICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXMgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkocmVzb2x2ZWRBcyk7XG4gICAgICAgICAgICBjb25zdCBhc1BhdGhuYW1lID0gcGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICBjb25zdCByb3V0ZVJlZ2V4ID0gKDAsIF9yb3V0ZXJlZ2V4LmdldFJvdXRlUmVnZXgpKHJvdXRlKTtcbiAgICAgICAgICAgIHJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKHJvdXRlUmVnZXgpKGFzUGF0aG5hbWUpO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkSW50ZXJwb2xhdGUgPSByb3V0ZSA9PT0gYXNQYXRobmFtZTtcbiAgICAgICAgICAgIGNvbnN0IGludGVycG9sYXRlZEFzID0gc2hvdWxkSW50ZXJwb2xhdGUgPyAoMCwgX2ludGVycG9sYXRlYXMuaW50ZXJwb2xhdGVBcykocm91dGUsIGFzUGF0aG5hbWUsIHF1ZXJ5KSA6IHt9O1xuICAgICAgICAgICAgaWYgKCFyb3V0ZU1hdGNoIHx8IHNob3VsZEludGVycG9sYXRlICYmICFpbnRlcnBvbGF0ZWRBcy5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtaXNzaW5nUGFyYW1zID0gT2JqZWN0LmtleXMocm91dGVSZWdleC5ncm91cHMpLmZpbHRlcigocGFyYW0pPT4hcXVlcnlbcGFyYW1dICYmICFyb3V0ZVJlZ2V4Lmdyb3Vwc1twYXJhbV0ub3B0aW9uYWwpO1xuICAgICAgICAgICAgICAgIGlmIChtaXNzaW5nUGFyYW1zLmxlbmd0aCA+IDAgJiYgIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlwiICsgKHNob3VsZEludGVycG9sYXRlID8gXCJJbnRlcnBvbGF0aW5nIGhyZWZcIiA6IFwiTWlzbWF0Y2hpbmcgYGFzYCBhbmQgYGhyZWZgXCIpICsgXCIgZmFpbGVkIHRvIG1hbnVhbGx5IHByb3ZpZGUgXCIgKyAoXCJ0aGUgcGFyYW1zOiBcIiArIG1pc3NpbmdQYXJhbXMuam9pbihcIiwgXCIpICsgXCIgaW4gdGhlIGBocmVmYCdzIGBxdWVyeWBcIikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigoc2hvdWxkSW50ZXJwb2xhdGUgPyBcIlRoZSBwcm92aWRlZCBgaHJlZmAgKFwiICsgdXJsICsgXCIpIHZhbHVlIGlzIG1pc3NpbmcgcXVlcnkgdmFsdWVzIChcIiArIG1pc3NpbmdQYXJhbXMuam9pbihcIiwgXCIpICsgXCIpIHRvIGJlIGludGVycG9sYXRlZCBwcm9wZXJseS4gXCIgOiBcIlRoZSBwcm92aWRlZCBgYXNgIHZhbHVlIChcIiArIGFzUGF0aG5hbWUgKyBcIikgaXMgaW5jb21wYXRpYmxlIHdpdGggdGhlIGBocmVmYCB2YWx1ZSAoXCIgKyByb3V0ZSArIFwiKS4gXCIpICsgKFwiUmVhZCBtb3JlOiBodHRwczovL25leHRqcy5vcmcvZG9jcy9tZXNzYWdlcy9cIiArIChzaG91bGRJbnRlcnBvbGF0ZSA/IFwiaHJlZi1pbnRlcnBvbGF0aW9uLWZhaWxlZFwiIDogXCJpbmNvbXBhdGlibGUtaHJlZi1hc1wiKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSW50ZXJwb2xhdGUpIHtcbiAgICAgICAgICAgICAgICBhcyA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShPYmplY3QuYXNzaWduKHt9LCBwYXJzZWRBcywge1xuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogaW50ZXJwb2xhdGVkQXMucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICBxdWVyeTogKDAsIF9vbWl0Lm9taXQpKHF1ZXJ5LCBpbnRlcnBvbGF0ZWRBcy5wYXJhbXMpXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBNZXJnZSBwYXJhbXMgaW50byBgcXVlcnlgLCBvdmVyd3JpdGluZyBhbnkgc3BlY2lmaWVkIGluIHNlYXJjaFxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ocXVlcnksIHJvdXRlTWF0Y2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZVN0YXJ0XCIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0Vycm9yUm91dGUgPSB0aGlzLnBhdGhuYW1lID09PSBcIi80MDRcIiB8fCB0aGlzLnBhdGhuYW1lID09PSBcIi9fZXJyb3JcIjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcywgX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcywgX3JvdXRlSW5mb19wcm9wcztcbiAgICAgICAgICAgIGxldCByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICByb3V0ZVByb3BzLFxuICAgICAgICAgICAgICAgIGxvY2FsZTogbmV4dFN0YXRlLmxvY2FsZSxcbiAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgaGFzTWlkZGxld2FyZTogaXNNaWRkbGV3YXJlTWF0Y2gsXG4gICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSxcbiAgICAgICAgICAgICAgICBpc1F1ZXJ5VXBkYXRpbmc6IGlzUXVlcnlVcGRhdGluZyAmJiAhdGhpcy5pc0ZhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGlzTWlkZGxld2FyZVJld3JpdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKCFpc1F1ZXJ5VXBkYXRpbmcgJiYgIW9wdGlvbnMuc2hhbGxvdykge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2JmbChhcywgXCJyZXNvbHZlZEFzXCIgaW4gcm91dGVJbmZvID8gcm91dGVJbmZvLnJlc29sdmVkQXMgOiB1bmRlZmluZWQsIG5leHRTdGF0ZS5sb2NhbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKFwicm91dGVcIiBpbiByb3V0ZUluZm8gJiYgaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJvdXRlSW5mby5yb3V0ZSB8fCByb3V0ZTtcbiAgICAgICAgICAgICAgICByb3V0ZSA9IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmICghcm91dGVQcm9wcy5zaGFsbG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0gT2JqZWN0LmFzc2lnbih7fSwgcm91dGVJbmZvLnF1ZXJ5IHx8IHt9LCBxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNsZWFuZWRQYXJzZWRQYXRobmFtZSA9ICgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHBhcnNlZC5wYXRobmFtZSkgPyAoMCwgX3JlbW92ZWJhc2VwYXRoLnJlbW92ZUJhc2VQYXRoKShwYXJzZWQucGF0aG5hbWUpIDogcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZU1hdGNoICYmIHBhdGhuYW1lICE9PSBjbGVhbmVkUGFyc2VkUGF0aG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMocm91dGVNYXRjaCkuZm9yRWFjaCgoa2V5KT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlTWF0Y2ggJiYgcXVlcnlba2V5XSA9PT0gcm91dGVNYXRjaFtrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHF1ZXJ5W2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhlZEFzID0gIXJvdXRlUHJvcHMuc2hhbGxvdyAmJiByb3V0ZUluZm8ucmVzb2x2ZWRBcyA/IHJvdXRlSW5mby5yZXNvbHZlZEFzIDogKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkoKDAsIF9hZGRsb2NhbGUuYWRkTG9jYWxlKShuZXcgVVJMKGFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSwgbmV4dFN0YXRlLmxvY2FsZSksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmV3cml0ZUFzID0gcHJlZml4ZWRBcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKCgwLCBfaGFzYmFzZXBhdGguaGFzQmFzZVBhdGgpKHJld3JpdGVBcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJld3JpdGVBcyA9ICgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVBcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Ll9fTkVYVF9JMThOX1NVUFBPUlQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsZVJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShyZXdyaXRlQXMsIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXh0U3RhdGUubG9jYWxlID0gbG9jYWxlUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IG5leHRTdGF0ZS5sb2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXdyaXRlQXMgPSBsb2NhbGVSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm91dGVSZWdleCA9ICgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clJvdXRlTWF0Y2ggPSAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKHJvdXRlUmVnZXgpKG5ldyBVUkwocmV3cml0ZUFzLCBsb2NhdGlvbi5ocmVmKS5wYXRobmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJSb3V0ZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCBjdXJSb3V0ZU1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSByb3V0ZUluZm8gYnJpbmdzIGEgcmVkaXJlY3Qgd2Ugc2ltcGx5IGFwcGx5IGl0LlxuICAgICAgICAgICAgaWYgKFwidHlwZVwiIGluIHJvdXRlSW5mbykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8udHlwZSA9PT0gXCJyZWRpcmVjdC1pbnRlcm5hbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNoYW5nZShtZXRob2QsIHJvdXRlSW5mby5uZXdVcmwsIHJvdXRlSW5mby5uZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiByb3V0ZUluZm8uZGVzdGluYXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgoKT0+e30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IHJvdXRlSW5mby5Db21wb25lbnQ7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY3JpcHRzID0gW10uY29uY2F0KGNvbXBvbmVudC51bnN0YWJsZV9zY3JpcHRMb2FkZXIoKSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0cy5mb3JFYWNoKChzY3JpcHQpPT57XG4gICAgICAgICAgICAgICAgICAgICgwLCBfc2NyaXB0LmhhbmRsZUNsaWVudFNjcmlwdExvYWQpKHNjcmlwdC5wcm9wcyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBoYW5kbGUgcmVkaXJlY3Qgb24gY2xpZW50LXRyYW5zaXRpb25cbiAgICAgICAgICAgIGlmICgocm91dGVJbmZvLl9fTl9TU0cgfHwgcm91dGVJbmZvLl9fTl9TU1ApICYmIHJvdXRlSW5mby5wcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChyb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzICYmIHJvdXRlSW5mby5wcm9wcy5wYWdlUHJvcHMuX19OX1JFRElSRUNUKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSB0aGUgZGVzdGluYXRpb24gZnJvbSByZWRpcmVjdCB3aXRob3V0IGFkZGluZyBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLl9fTl9SRURJUkVDVDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgZGVzdGluYXRpb24gaXMgaW50ZXJuYWwgKHJlc29sdmVzIHRvIGEgcGFnZSkgYW5kIGF0dGVtcHRcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xpZW50LW5hdmlnYXRpb24gaWYgaXQgaXMgZmFsbGluZyBiYWNrIHRvIGhhcmQgbmF2aWdhdGlvbiBpZlxuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG5vdFxuICAgICAgICAgICAgICAgICAgICBpZiAoZGVzdGluYXRpb24uc3RhcnRzV2l0aChcIi9cIikgJiYgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5fX05fUkVESVJFQ1RfQkFTRV9QQVRIICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkSHJlZiA9ICgwLCBfcGFyc2VyZWxhdGl2ZXVybC5wYXJzZVJlbGF0aXZlVXJsKShkZXN0aW5hdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRIcmVmLnBhdGhuYW1lID0gcmVzb2x2ZUR5bmFtaWNSb3V0ZShwYXJzZWRIcmVmLnBhdGhuYW1lLCBwYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHVybDogbmV3VXJsLCBhczogbmV3QXMgfSA9IHByZXBhcmVVcmxBcyh0aGlzLCBkZXN0aW5hdGlvbiwgZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlKG1ldGhvZCwgbmV3VXJsLCBuZXdBcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlSGFyZE5hdmlnYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiBkZXN0aW5hdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRTdGF0ZS5pc1ByZXZpZXcgPSAhIXJvdXRlSW5mby5wcm9wcy5fX05fUFJFVklFVztcbiAgICAgICAgICAgICAgICAvLyBoYW5kbGUgU1NHIGRhdGEgNDA0XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5wcm9wcy5ub3RGb3VuZCA9PT0gU1NHX0RBVEFfTk9UX0ZPVU5EKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBub3RGb3VuZFJvdXRlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChcIi80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RGb3VuZFJvdXRlID0gXCIvNDA0XCI7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdEZvdW5kUm91dGUgPSBcIi9fZXJyb3JcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZTogbm90Rm91bmRSb3V0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGhuYW1lOiBub3RGb3VuZFJvdXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhbGxvdzogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpZXc6IG5leHRTdGF0ZS5pc1ByZXZpZXcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc05vdEZvdW5kOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoXCJ0eXBlXCIgaW4gcm91dGVJbmZvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIG1pZGRsZXdhcmUgZWZmZWN0IG9uIC80MDRcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIHRoaXMucGF0aG5hbWUgPT09IFwiL19lcnJvclwiICYmICgoX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wcyA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wcyA9IF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMucGFnZVByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMgPSByb3V0ZUluZm8ucHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcm91dGVJbmZvX3Byb3BzLnBhZ2VQcm9wcykpIHtcbiAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAvLyB3aGVuIHVwZGF0aW5nIHF1ZXJ5IGluZm9ybWF0aW9uXG4gICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzLnBhZ2VQcm9wcy5zdGF0dXNDb2RlID0gNTAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb3V0ZUluZm9fcm91dGU7XG4gICAgICAgICAgICAvLyBzaGFsbG93IHJvdXRpbmcgaXMgb25seSBhbGxvd2VkIGZvciBzYW1lIHBhZ2UgVVJMIGNoYW5nZXMuXG4gICAgICAgICAgICBjb25zdCBpc1ZhbGlkU2hhbGxvd1JvdXRlID0gb3B0aW9ucy5zaGFsbG93ICYmIG5leHRTdGF0ZS5yb3V0ZSA9PT0gKChfcm91dGVJbmZvX3JvdXRlID0gcm91dGVJbmZvLnJvdXRlKSAhPSBudWxsID8gX3JvdXRlSW5mb19yb3V0ZSA6IHJvdXRlKTtcbiAgICAgICAgICAgIHZhciBfb3B0aW9uc19zY3JvbGw7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRTY3JvbGwgPSAoX29wdGlvbnNfc2Nyb2xsID0gb3B0aW9ucy5zY3JvbGwpICE9IG51bGwgPyBfb3B0aW9uc19zY3JvbGwgOiAhaXNRdWVyeVVwZGF0aW5nICYmICFpc1ZhbGlkU2hhbGxvd1JvdXRlO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRTY3JvbGwgPSBzaG91bGRTY3JvbGwgPyB7XG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwXG4gICAgICAgICAgICB9IDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHVwY29taW5nU2Nyb2xsU3RhdGUgPSBmb3JjZWRTY3JvbGwgIT0gbnVsbCA/IGZvcmNlZFNjcm9sbCA6IHJlc2V0U2Nyb2xsO1xuICAgICAgICAgICAgLy8gdGhlIG5ldyBzdGF0ZSB0aGF0IHRoZSByb3V0ZXIgZ29ubmEgc2V0XG4gICAgICAgICAgICBjb25zdCB1cGNvbWluZ1JvdXRlclN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLm5leHRTdGF0ZSxcbiAgICAgICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgICAgICBhc1BhdGg6IGNsZWFuZWRBcyxcbiAgICAgICAgICAgICAgICBpc0ZhbGxiYWNrOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIHBhZ2UgYmVpbmcgcmVuZGVyZWQgaXMgdGhlIDQwNCBwYWdlLCB3ZSBzaG91bGQgb25seSB1cGRhdGUgdGhlXG4gICAgICAgICAgICAvLyBxdWVyeSBwYXJhbWV0ZXJzLiBSb3V0ZSBjaGFuZ2VzIGhlcmUgbWlnaHQgYWRkIHRoZSBiYXNlUGF0aCB3aGVuIGl0XG4gICAgICAgICAgICAvLyB3YXNuJ3Qgb3JpZ2luYWxseSBwcmVzZW50LiBUaGlzIGlzIGFsc28gd2h5IHRoaXMgYmxvY2sgaXMgYmVmb3JlIHRoZVxuICAgICAgICAgICAgLy8gYmVsb3cgYGNoYW5nZVN0YXRlYCBjYWxsIHdoaWNoIHVwZGF0ZXMgdGhlIGJyb3dzZXIncyBoaXN0b3J5IChjaGFuZ2luZ1xuICAgICAgICAgICAgLy8gdGhlIFVSTCkuXG4gICAgICAgICAgICBpZiAoaXNRdWVyeVVwZGF0aW5nICYmIGlzRXJyb3JSb3V0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEsIF9zZWxmX19fTkVYVF9EQVRBX19fcHJvcHMxLCBfcm91dGVJbmZvX3Byb3BzMTtcbiAgICAgICAgICAgICAgICByb3V0ZUluZm8gPSBhd2FpdCB0aGlzLmdldFJvdXRlSW5mbyh7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlOiB0aGlzLnBhdGhuYW1lLFxuICAgICAgICAgICAgICAgICAgICBwYXRobmFtZTogdGhpcy5wYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICAgICAgICAgIGFzLFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICByb3V0ZVByb3BzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzaGFsbG93OiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IG5leHRTdGF0ZS5sb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGlzUHJldmlldzogbmV4dFN0YXRlLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNRdWVyeVVwZGF0aW5nOiBpc1F1ZXJ5VXBkYXRpbmcgJiYgIXRoaXMuaXNGYWxsYmFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcInR5cGVcIiBpbiByb3V0ZUluZm8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBtaWRkbGV3YXJlIGVmZmVjdCBvbiBcIiArIHRoaXMucGF0aG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgJiYgKChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMSA9IHNlbGYuX19ORVhUX0RBVEFfXy5wcm9wcykgPT0gbnVsbCA/IHZvaWQgMCA6IChfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEgPSBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzMS5wYWdlUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzX3BhZ2VQcm9wczEuc3RhdHVzQ29kZSkgPT09IDUwMCAmJiAoKF9yb3V0ZUluZm9fcHJvcHMxID0gcm91dGVJbmZvLnByb3BzKSA9PSBudWxsID8gdm9pZCAwIDogX3JvdXRlSW5mb19wcm9wczEucGFnZVByb3BzKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBlbnN1cmUgc3RhdHVzQ29kZSBpcyBzdGlsbCBjb3JyZWN0IGZvciBzdGF0aWMgNTAwIHBhZ2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiB1cGRhdGluZyBxdWVyeSBpbmZvcm1hdGlvblxuICAgICAgICAgICAgICAgICAgICByb3V0ZUluZm8ucHJvcHMucGFnZVByb3BzLnN0YXR1c0NvZGUgPSA1MDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0KHVwY29taW5nUm91dGVyU3RhdGUsIHJvdXRlSW5mbywgdXBjb21pbmdTY3JvbGxTdGF0ZSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBSb3V0ZXIuZXZlbnRzLmVtaXQoXCJyb3V0ZUNoYW5nZUVycm9yXCIsIGVyciwgY2xlYW5lZEFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwiYmVmb3JlSGlzdG9yeUNoYW5nZVwiLCBhcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucyk7XG4gICAgICAgICAgICAvLyBmb3IgcXVlcnkgdXBkYXRlcyB3ZSBjYW4gc2tpcCBpdCBpZiB0aGUgc3RhdGUgaXMgdW5jaGFuZ2VkIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gbmVlZCB0byBzY3JvbGxcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9pc3N1ZXMvMzcxMzlcbiAgICAgICAgICAgIGNvbnN0IGNhblNraXBVcGRhdGluZyA9IGlzUXVlcnlVcGRhdGluZyAmJiAhdXBjb21pbmdTY3JvbGxTdGF0ZSAmJiAhcmVhZHlTdGF0ZUNoYW5nZSAmJiAhbG9jYWxlQ2hhbmdlICYmICgwLCBfY29tcGFyZXN0YXRlcy5jb21wYXJlUm91dGVyU3RhdGVzKSh1cGNvbWluZ1JvdXRlclN0YXRlLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgIGlmICghY2FuU2tpcFVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXQodXBjb21pbmdSb3V0ZXJTdGF0ZSwgcm91dGVJbmZvLCB1cGNvbWluZ1Njcm9sbFN0YXRlKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGxlZCkgcm91dGVJbmZvLmVycm9yID0gcm91dGVJbmZvLmVycm9yIHx8IGU7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJvdXRlSW5mby5lcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCByb3V0ZUluZm8uZXJyb3IsIGNsZWFuZWRBcywgcm91dGVQcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgcm91dGVJbmZvLmVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlLmxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmxhbmcgPSBuZXh0U3RhdGUubG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIFJvdXRlci5ldmVudHMuZW1pdChcInJvdXRlQ2hhbmdlQ29tcGxldGVcIiwgYXMsIHJvdXRlUHJvcHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBIGhhc2ggbWFyayAjIGlzIHRoZSBvcHRpb25hbCBsYXN0IHBhcnQgb2YgYSBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCBoYXNoUmVnZXggPSAvIy4rJC87XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZFNjcm9sbCAmJiBoYXNoUmVnZXgudGVzdChhcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxUb0hhc2goYXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmICgoMCwgX2lzZXJyb3IuZGVmYXVsdCkoZXJyKSAmJiBlcnIuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoYW5nZVN0YXRlKG1ldGhvZCwgdXJsLCBhcywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93Lmhpc3RvcnkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiV2FybmluZzogd2luZG93Lmhpc3RvcnkgaXMgbm90IGF2YWlsYWJsZS5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cuaGlzdG9yeVttZXRob2RdID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIldhcm5pbmc6IHdpbmRvdy5oaXN0b3J5LlwiICsgbWV0aG9kICsgXCIgaXMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1ldGhvZCAhPT0gXCJwdXNoU3RhdGVcIiB8fCAoMCwgX3V0aWxzLmdldFVSTCkoKSAhPT0gYXMpIHtcbiAgICAgICAgICAgIHRoaXMuX3NoYWxsb3cgPSBvcHRpb25zLnNoYWxsb3c7XG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeVttZXRob2RdKHtcbiAgICAgICAgICAgICAgICB1cmwsXG4gICAgICAgICAgICAgICAgYXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgICAgICBfX046IHRydWUsXG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLl9rZXkgPSBtZXRob2QgIT09IFwicHVzaFN0YXRlXCIgPyB0aGlzLl9rZXkgOiBjcmVhdGVLZXkoKVxuICAgICAgICAgICAgfSwgLy8gTW9zdCBicm93c2VycyBjdXJyZW50bHkgaWdub3JlcyB0aGlzIHBhcmFtZXRlciwgYWx0aG91Z2ggdGhleSBtYXkgdXNlIGl0IGluIHRoZSBmdXR1cmUuXG4gICAgICAgICAgICAvLyBQYXNzaW5nIHRoZSBlbXB0eSBzdHJpbmcgaGVyZSBzaG91bGQgYmUgc2FmZSBhZ2FpbnN0IGZ1dHVyZSBjaGFuZ2VzIHRvIHRoZSBtZXRob2QuXG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvSGlzdG9yeS9yZXBsYWNlU3RhdGVcbiAgICAgICAgICAgIFwiXCIsIGFzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBoYW5kbGVSb3V0ZUluZm9FcnJvcihlcnIsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIGxvYWRFcnJvckZhaWwpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICBpZiAoZXJyLmNhbmNlbGxlZCkge1xuICAgICAgICAgICAgLy8gYnViYmxlIHVwIGNhbmNlbGxhdGlvbiBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKDAsIF9yb3V0ZWxvYWRlci5pc0Fzc2V0RXJyb3IpKGVycikgfHwgbG9hZEVycm9yRmFpbCkge1xuICAgICAgICAgICAgUm91dGVyLmV2ZW50cy5lbWl0KFwicm91dGVDaGFuZ2VFcnJvclwiLCBlcnIsIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgICAgIC8vIElmIHdlIGNhbid0IGxvYWQgdGhlIHBhZ2UgaXQgY291bGQgYmUgb25lIG9mIGZvbGxvd2luZyByZWFzb25zXG4gICAgICAgICAgICAvLyAgMS4gUGFnZSBkb2Vzbid0IGV4aXN0c1xuICAgICAgICAgICAgLy8gIDIuIFBhZ2UgZG9lcyBleGlzdCBpbiBhIGRpZmZlcmVudCB6b25lXG4gICAgICAgICAgICAvLyAgMy4gSW50ZXJuYWwgZXJyb3Igd2hpbGUgbG9hZGluZyB0aGUgcGFnZVxuICAgICAgICAgICAgLy8gU28sIGRvaW5nIGEgaGFyZCByZWxvYWQgaXMgdGhlIHByb3BlciB3YXkgdG8gZGVhbCB3aXRoIHRoaXMuXG4gICAgICAgICAgICBoYW5kbGVIYXJkTmF2aWdhdGlvbih7XG4gICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hhbmdpbmcgdGhlIFVSTCBkb2Vzbid0IGJsb2NrIGV4ZWN1dGluZyB0aGUgY3VycmVudCBjb2RlIHBhdGguXG4gICAgICAgICAgICAvLyBTbyBsZXQncyB0aHJvdyBhIGNhbmNlbGxhdGlvbiBlcnJvciBzdG9wIHRoZSByb3V0aW5nIGxvZ2ljLlxuICAgICAgICAgICAgdGhyb3cgYnVpbGRDYW5jZWxsYXRpb25FcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgcHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHBhZ2U6IENvbXBvbmVudCwgc3R5bGVTaGVldHMgfSA9IGF3YWl0IHRoaXMuZmV0Y2hDb21wb25lbnQoXCIvX2Vycm9yXCIpO1xuICAgICAgICAgICAgY29uc3Qgcm91dGVJbmZvID0ge1xuICAgICAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICAgICBzdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVyclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghcm91dGVJbmZvLnByb3BzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gYXdhaXQgdGhpcy5nZXRJbml0aWFsUHJvcHMoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGdpcEVycikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZXJyb3IgcGFnZSBgZ2V0SW5pdGlhbFByb3BzYDogXCIsIGdpcEVycik7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlSW5mby5wcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKHJvdXRlSW5mb0Vycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmRlZmF1bHQpKHJvdXRlSW5mb0VycikgPyByb3V0ZUluZm9FcnIgOiBuZXcgRXJyb3Iocm91dGVJbmZvRXJyICsgXCJcIiksIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJvdXRlUHJvcHMsIHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFJvdXRlSW5mbyhwYXJhbSkge1xuICAgICAgICBsZXQgeyByb3V0ZTogcmVxdWVzdGVkUm91dGUsIHBhdGhuYW1lLCBxdWVyeSwgYXMsIHJlc29sdmVkQXMsIHJvdXRlUHJvcHMsIGxvY2FsZSwgaGFzTWlkZGxld2FyZSwgaXNQcmV2aWV3LCB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsIGlzUXVlcnlVcGRhdGluZywgaXNNaWRkbGV3YXJlUmV3cml0ZSwgaXNOb3RGb3VuZCB9ID0gcGFyYW07XG4gICAgICAgIC8qKlxuICAgICAqIFRoaXMgYHJvdXRlYCBiaW5kaW5nIGNhbiBjaGFuZ2UgaWYgdGhlcmUncyBhIHJld3JpdGVcbiAgICAgKiBzbyB3ZSBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCByZXF1ZXN0ZWQgcm91dGVcbiAgICAgKiBzbyB3ZSBjYW4gc3RvcmUgdGhlIGNhY2hlIGZvciBpdCBhbmQgYXZvaWQgcmUtcmVxdWVzdGluZyBldmVyeSB0aW1lXG4gICAgICogZm9yIHNoYWxsb3cgcm91dGluZyBwdXJwb3Nlcy5cbiAgICAgKi8gbGV0IHJvdXRlID0gcmVxdWVzdGVkUm91dGU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2RhdGFfZWZmZWN0LCBfZGF0YV9lZmZlY3QxLCBfZGF0YV9lZmZlY3QyLCBfZGF0YV9yZXNwb25zZTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUNhbmNlbGxlZCA9IGdldENhbmNlbGxlZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBsZXQgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgIGlmIChyb3V0ZVByb3BzLnNoYWxsb3cgJiYgZXhpc3RpbmdJbmZvICYmIHRoaXMucm91dGUgPT09IHJvdXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nSW5mbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhY2hlZFJvdXRlSW5mbyA9IGV4aXN0aW5nSW5mbyAmJiAhKFwiaW5pdGlhbFwiIGluIGV4aXN0aW5nSW5mbykgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwiZGV2ZWxvcG1lbnRcIiA/IGV4aXN0aW5nSW5mbyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzQmFja2dyb3VuZCA9IGlzUXVlcnlVcGRhdGluZztcbiAgICAgICAgICAgIGNvbnN0IGZldGNoTmV4dERhdGFQYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YUhyZWY6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBza2lwSW50ZXJwb2xhdGlvbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBpc05vdEZvdW5kID8gXCIvNDA0XCIgOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBoYXNNaWRkbGV3YXJlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgIHBhcnNlSlNPTjogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbmZsaWdodENhY2hlOiBpc0JhY2tncm91bmQgPyB0aGlzLnNiYyA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogIWlzUHJldmlldyxcbiAgICAgICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGUsXG4gICAgICAgICAgICAgICAgaXNCYWNrZ3JvdW5kXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpc1F1ZXJ5VXBkYXRpbmcgJiYgIWlzTWlkZGxld2FyZVJld3JpdGUgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgICAgICBmZXRjaERhdGE6ICgpPT5mZXRjaE5leHREYXRhKGZldGNoTmV4dERhdGFQYXJhbXMpLFxuICAgICAgICAgICAgICAgIGFzUGF0aDogaXNOb3RGb3VuZCA/IFwiLzQwNFwiIDogcmVzb2x2ZWRBcyxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICByb3V0ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpPT57XG4gICAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGFyZCBlcnJvciBkdXJpbmcgcXVlcnkgdXBkYXRpbmdcbiAgICAgICAgICAgICAgICAvLyBhcyBpdCdzIHVuLW5lY2Vzc2FyeSBhbmQgZG9lc24ndCBuZWVkIHRvIGJlIGZhdGFsXG4gICAgICAgICAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgZmFsbGJhY2sgcm91dGUgYW5kIHRoZSBwcm9wcyBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGJlIGxvYWRlZFxuICAgICAgICAgICAgICAgIGlmIChpc1F1ZXJ5VXBkYXRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gd2hlbiByZW5kZXJpbmcgZXJyb3Igcm91dGVzIHdlIGRvbid0IGFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgICAgIC8vIGVmZmVjdHNcbiAgICAgICAgICAgIGlmIChkYXRhICYmIChwYXRobmFtZSA9PT0gXCIvX2Vycm9yXCIgfHwgcGF0aG5hbWUgPT09IFwiLzQwNFwiKSkge1xuICAgICAgICAgICAgICAgIGRhdGEuZWZmZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbjogc2VsZi5fX05FWFRfREFUQV9fLnByb3BzXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5qc29uID0gc2VsZi5fX05FWFRfREFUQV9fLnByb3BzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbGxlZCgpO1xuICAgICAgICAgICAgaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfZWZmZWN0ID0gZGF0YS5lZmZlY3QpID09IG51bGwgPyB2b2lkIDAgOiBfZGF0YV9lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtaW50ZXJuYWxcIiB8fCAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDEgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDEudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkYXRhLmVmZmVjdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogKF9kYXRhX2VmZmVjdDIgPSBkYXRhLmVmZmVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9kYXRhX2VmZmVjdDIudHlwZSkgPT09IFwicmV3cml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRSb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgICAgICAgICAgLy8gZHVyaW5nIHF1ZXJ5IHVwZGF0aW5nIHRoZSBwYWdlIG11c3QgbWF0Y2ggYWx0aG91Z2ggZHVyaW5nXG4gICAgICAgICAgICAgICAgLy8gY2xpZW50LXRyYW5zaXRpb24gYSByZWRpcmVjdCB0aGF0IGRvZXNuJ3QgbWF0Y2ggYSBwYWdlXG4gICAgICAgICAgICAgICAgLy8gY2FuIGJlIHJldHVybmVkIGFuZCB0aGlzIHNob3VsZCB0cmlnZ2VyIGEgaGFyZCBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gd2hpY2ggaXMgdmFsaWQgZm9yIGluY3JlbWVudGFsIG1pZ3JhdGlvblxuICAgICAgICAgICAgICAgIGlmICghaXNRdWVyeVVwZGF0aW5nIHx8IHBhZ2VzLmluY2x1ZGVzKHJlc29sdmVkUm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdXRlID0gcmVzb2x2ZWRSb3V0ZTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUgPSBkYXRhLmVmZmVjdC5yZXNvbHZlZEhyZWY7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5kYXRhLmVmZmVjdC5wYXJzZWRBcy5xdWVyeVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlZEFzID0gKDAsIF9yZW1vdmViYXNlcGF0aC5yZW1vdmVCYXNlUGF0aCkoKDAsIF9ub3JtYWxpemVsb2NhbGVwYXRoLm5vcm1hbGl6ZUxvY2FsZVBhdGgpKGRhdGEuZWZmZWN0LnBhcnNlZEFzLnBhdGhuYW1lLCB0aGlzLmxvY2FsZXMpLnBhdGhuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgYWdhaW4gdGhlIGNhY2hlIHdpdGggdGhlIG5ldyBkZXN0aW5hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdJbmZvID0gdGhpcy5jb21wb25lbnRzW3JvdXRlXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJvdXRlUHJvcHMuc2hhbGxvdyAmJiBleGlzdGluZ0luZm8gJiYgdGhpcy5yb3V0ZSA9PT0gcm91dGUgJiYgIWhhc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXRjaCB3aXRoIHRoZSBjdXJyZW50IHJvdXRlIGR1ZSB0byByZXdyaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIGNvcHkgdGhlIGV4aXN0aW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZXdyaXR0ZW4gb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlbiwgd2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhbG9uZyB3aXRoIHRoZSBtYXRjaGVkIHJvdXRlLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5leGlzdGluZ0luZm8sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm91dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIF9pc2FwaXJvdXRlLmlzQVBJUm91dGUpKHJvdXRlKSkge1xuICAgICAgICAgICAgICAgIGhhbmRsZUhhcmROYXZpZ2F0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByb3V0ZUluZm8gPSBjYWNoZWRSb3V0ZUluZm8gfHwgYXdhaXQgdGhpcy5mZXRjaENvbXBvbmVudChyb3V0ZSkudGhlbigocmVzKT0+KHtcbiAgICAgICAgICAgICAgICAgICAgQ29tcG9uZW50OiByZXMucGFnZSxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVTaGVldHM6IHJlcy5zdHlsZVNoZWV0cyxcbiAgICAgICAgICAgICAgICAgICAgX19OX1NTRzogcmVzLm1vZC5fX05fU1NHLFxuICAgICAgICAgICAgICAgICAgICBfX05fU1NQOiByZXMubW9kLl9fTl9TU1BcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpc1ZhbGlkRWxlbWVudFR5cGUgfSA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QtaXNcIik7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudFR5cGUocm91dGVJbmZvLkNvbXBvbmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZGVmYXVsdCBleHBvcnQgaXMgbm90IGEgUmVhY3QgQ29tcG9uZW50IGluIHBhZ2U6IFwiJyArIHBhdGhuYW1lICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2FzQmFpbGVkUHJlZmV0Y2ggPSBkYXRhID09IG51bGwgPyB2b2lkIDAgOiAoX2RhdGFfcmVzcG9uc2UgPSBkYXRhLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2RhdGFfcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJ4LW1pZGRsZXdhcmUtc2tpcFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZEZldGNoRGF0YSA9IHJvdXRlSW5mby5fX05fU1NHIHx8IHJvdXRlSW5mby5fX05fU1NQO1xuICAgICAgICAgICAgLy8gRm9yIG5vbi1TU0cgcHJlZmV0Y2hlcyB0aGF0IGJhaWxlZCBiZWZvcmUgc2VuZGluZyBkYXRhXG4gICAgICAgICAgICAvLyB3ZSBjbGVhciB0aGUgY2FjaGUgdG8gZmV0Y2ggZnVsbCByZXNwb25zZVxuICAgICAgICAgICAgaWYgKHdhc0JhaWxlZFByZWZldGNoICYmIChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmRhdGFIcmVmKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNkY1tkYXRhLmRhdGFIcmVmXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcHJvcHMsIGNhY2hlS2V5IH0gPSBhd2FpdCB0aGlzLl9nZXREYXRhKGFzeW5jICgpPT57XG4gICAgICAgICAgICAgICAgaWYgKHNob3VsZEZldGNoRGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoKGRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IGRhdGEuanNvbikgJiYgIXdhc0JhaWxlZFByZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhY2hlS2V5OiBkYXRhLmNhY2hlS2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBkYXRhLmpzb25cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGF0YUhyZWYgPSAoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZikgPyBkYXRhLmRhdGFIcmVmIDogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiByZXNvbHZlZEFzLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmZXRjaGVkID0gYXdhaXQgZmV0Y2hOZXh0RGF0YSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VKU09OOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5mbGlnaHRDYWNoZTogd2FzQmFpbGVkUHJlZmV0Y2ggPyB7fSA6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGVyc2lzdENhY2hlOiAhaXNQcmV2aWV3LFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB1bnN0YWJsZV9za2lwQ2xpZW50Q2FjaGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWNoZUtleTogZmV0Y2hlZC5jYWNoZUtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BzOiBmZXRjaGVkLmpzb24gfHwge31cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge30sXG4gICAgICAgICAgICAgICAgICAgIHByb3BzOiBhd2FpdCB0aGlzLmdldEluaXRpYWxQcm9wcyhyb3V0ZUluZm8uQ29tcG9uZW50LCAvLyB3ZSBwcm92aWRlIEFwcFRyZWUgbGF0ZXIgc28gdGhpcyBuZWVkcyB0byBiZSBgYW55YFxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYXNQYXRoOiBhcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsZXM6IHRoaXMubG9jYWxlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRMb2NhbGU6IHRoaXMuZGVmYXVsdExvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE9ubHkgYnVzdCB0aGUgZGF0YSBjYWNoZSBmb3IgU1NQIHJvdXRlcyBhbHRob3VnaFxuICAgICAgICAgICAgLy8gbWlkZGxld2FyZSBjYW4gc2tpcCBjYWNoZSBwZXIgcmVxdWVzdCB3aXRoXG4gICAgICAgICAgICAvLyB4LW1pZGRsZXdhcmUtY2FjaGU6IG5vLWNhY2hlIGFzIHdlbGxcbiAgICAgICAgICAgIGlmIChyb3V0ZUluZm8uX19OX1NTUCAmJiBmZXRjaE5leHREYXRhUGFyYW1zLmRhdGFIcmVmICYmIGNhY2hlS2V5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuc2RjW2NhY2hlS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHdlIGtpY2sgb2ZmIGEgSEVBRCByZXF1ZXN0IGluIHRoZSBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAvLyB3aGVuIGEgbm9uLXByZWZldGNoIHJlcXVlc3QgaXMgbWFkZSB0byBzaWduYWwgcmV2YWxpZGF0aW9uXG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNQcmV2aWV3ICYmIHJvdXRlSW5mby5fX05fU1NHICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcImRldmVsb3BtZW50XCIgJiYgIWlzUXVlcnlVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIGZldGNoTmV4dERhdGEoT2JqZWN0LmFzc2lnbih7fSwgZmV0Y2hOZXh0RGF0YVBhcmFtcywge1xuICAgICAgICAgICAgICAgICAgICBpc0JhY2tncm91bmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2JjXG4gICAgICAgICAgICAgICAgfSkpLmNhdGNoKCgpPT57fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9wcy5wYWdlUHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcy5wYWdlUHJvcHMpO1xuICAgICAgICAgICAgcm91dGVJbmZvLnByb3BzID0gcHJvcHM7XG4gICAgICAgICAgICByb3V0ZUluZm8ucm91dGUgPSByb3V0ZTtcbiAgICAgICAgICAgIHJvdXRlSW5mby5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgICAgICAgcm91dGVJbmZvLnJlc29sdmVkQXMgPSByZXNvbHZlZEFzO1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3JvdXRlXSA9IHJvdXRlSW5mbztcbiAgICAgICAgICAgIHJldHVybiByb3V0ZUluZm87XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlUm91dGVJbmZvRXJyb3IoKDAsIF9pc2Vycm9yLmdldFByb3BlckVycm9yKShlcnIpLCBwYXRobmFtZSwgcXVlcnksIGFzLCByb3V0ZVByb3BzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQoc3RhdGUsIGRhdGEsIHJlc2V0U2Nyb2xsKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ViKGRhdGEsIHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdLkNvbXBvbmVudCwgcmVzZXRTY3JvbGwpO1xuICAgIH1cbiAgICAvKipcbiAgICogQ2FsbGJhY2sgdG8gZXhlY3V0ZSBiZWZvcmUgcmVwbGFjaW5nIHJvdXRlciBzdGF0ZVxuICAgKiBAcGFyYW0gY2IgY2FsbGJhY2sgdG8gYmUgZXhlY3V0ZWRcbiAgICovIGJlZm9yZVBvcFN0YXRlKGNiKSB7XG4gICAgICAgIHRoaXMuX2JwcyA9IGNiO1xuICAgIH1cbiAgICBvbmx5QUhhc2hDaGFuZ2UoYXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFzUGF0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbb2xkVXJsTm9IYXNoLCBvbGRIYXNoXSA9IHRoaXMuYXNQYXRoLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgY29uc3QgW25ld1VybE5vSGFzaCwgbmV3SGFzaF0gPSBhcy5zcGxpdChcIiNcIik7XG4gICAgICAgIC8vIE1ha2VzIHN1cmUgd2Ugc2Nyb2xsIHRvIHRoZSBwcm92aWRlZCBoYXNoIGlmIHRoZSB1cmwvaGFzaCBhcmUgdGhlIHNhbWVcbiAgICAgICAgaWYgKG5ld0hhc2ggJiYgb2xkVXJsTm9IYXNoID09PSBuZXdVcmxOb0hhc2ggJiYgb2xkSGFzaCA9PT0gbmV3SGFzaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVybHMgYXJlIGNoYW5nZSwgdGhlcmUncyBtb3JlIHRoYW4gYSBoYXNoIGNoYW5nZVxuICAgICAgICBpZiAob2xkVXJsTm9IYXNoICE9PSBuZXdVcmxOb0hhc2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0aGUgaGFzaCBoYXMgY2hhbmdlZCwgdGhlbiBpdCdzIGEgaGFzaCBvbmx5IGNoYW5nZS5cbiAgICAgICAgLy8gVGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgdG8gaGFuZGxlIGJvdGggdGhlIGVudGVyIGFuZFxuICAgICAgICAvLyBsZWF2ZSBoYXNoID09PSAnJyBjYXNlcy4gVGhlIGlkZW50aXR5IGNhc2UgZmFsbHMgdGhyb3VnaFxuICAgICAgICAvLyBhbmQgaXMgdHJlYXRlZCBhcyBhIG5leHQgcmVsb2FkLlxuICAgICAgICByZXR1cm4gb2xkSGFzaCAhPT0gbmV3SGFzaDtcbiAgICB9XG4gICAgc2Nyb2xsVG9IYXNoKGFzKSB7XG4gICAgICAgIGNvbnN0IFssIGhhc2ggPSBcIlwiXSA9IGFzLnNwbGl0KFwiI1wiKTtcbiAgICAgICAgKDAsIF9oYW5kbGVzbW9vdGhzY3JvbGwuaGFuZGxlU21vb3RoU2Nyb2xsKSgoKT0+e1xuICAgICAgICAgICAgLy8gU2Nyb2xsIHRvIHRvcCBpZiB0aGUgaGFzaCBpcyBqdXN0IGAjYCB3aXRoIG5vIHZhbHVlIG9yIGAjdG9wYFxuICAgICAgICAgICAgLy8gVG8gbWlycm9yIGJyb3dzZXJzXG4gICAgICAgICAgICBpZiAoaGFzaCA9PT0gXCJcIiB8fCBoYXNoID09PSBcInRvcFwiKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlY29kZSBoYXNoIHRvIG1ha2Ugbm9uLWxhdGluIGFuY2hvciB3b3Jrcy5cbiAgICAgICAgICAgIGNvbnN0IHJhd0hhc2ggPSBkZWNvZGVVUklDb21wb25lbnQoaGFzaCk7XG4gICAgICAgICAgICAvLyBGaXJzdCB3ZSBjaGVjayBpZiB0aGUgZWxlbWVudCBieSBpZCBpcyBmb3VuZFxuICAgICAgICAgICAgY29uc3QgaWRFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJhd0hhc2gpO1xuICAgICAgICAgICAgaWYgKGlkRWwpIHtcbiAgICAgICAgICAgICAgICBpZEVsLnNjcm9sbEludG9WaWV3KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBubyBlbGVtZW50IHdpdGggdGhlIGlkLCB3ZSBjaGVjayB0aGUgYG5hbWVgIHByb3BlcnR5XG4gICAgICAgICAgICAvLyBUbyBtaXJyb3IgYnJvd3NlcnNcbiAgICAgICAgICAgIGNvbnN0IG5hbWVFbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKHJhd0hhc2gpWzBdO1xuICAgICAgICAgICAgaWYgKG5hbWVFbCkge1xuICAgICAgICAgICAgICAgIG5hbWVFbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBvbmx5SGFzaENoYW5nZTogdGhpcy5vbmx5QUhhc2hDaGFuZ2UoYXMpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cmxJc05ldyhhc1BhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNQYXRoICE9PSBhc1BhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgKiBQcmVmZXRjaCBwYWdlIGNvZGUsIHlvdSBtYXkgd2FpdCBmb3IgdGhlIGRhdGEgZHVyaW5nIHBhZ2UgcmVuZGVyaW5nLlxuICAgKiBUaGlzIGZlYXR1cmUgb25seSB3b3JrcyBpbiBwcm9kdWN0aW9uIVxuICAgKiBAcGFyYW0gdXJsIHRoZSBocmVmIG9mIHByZWZldGNoZWQgcGFnZVxuICAgKiBAcGFyYW0gYXNQYXRoIHRoZSBhcyBwYXRoIG9mIHRoZSBwcmVmZXRjaGVkIHBhZ2VcbiAgICovIGFzeW5jIHByZWZldGNoKHVybCwgYXNQYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChhc1BhdGggPT09IHZvaWQgMCkgYXNQYXRoID0gdXJsO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSBvcHRpb25zID0ge307XG4gICAgICAgIC8vIFByZWZldGNoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gZGV2ZWxvcG1lbnQgbW9kZSBiZWNhdXNlIGl0IHdvdWxkIHRyaWdnZXIgb24tZGVtYW5kLWVudHJpZXNcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmICgwLCBfaXNib3QuaXNCb3QpKHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgLy8gTm8gcHJlZmV0Y2hlcyBmb3IgYm90cyB0aGF0IHJlbmRlciB0aGUgbGluayBzaW5jZSB0aGV5IGFyZSB0eXBpY2FsbHkgbmF2aWdhdGluZ1xuICAgICAgICAgICAgLy8gbGlua3MgdmlhIHRoZSBlcXVpdmFsZW50IG9mIGEgaGFyZCBuYXZpZ2F0aW9uIGFuZCBoZW5jZSBuZXZlciB1dGlsaXplIHRoZXNlXG4gICAgICAgICAgICAvLyBwcmVmZXRjaGVzLlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJzZWQgPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgY29uc3QgdXJsUGF0aG5hbWUgPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgIGxldCB7IHBhdGhuYW1lLCBxdWVyeSB9ID0gcGFyc2VkO1xuICAgICAgICBjb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5sb2NhbGUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcGF0aG5hbWUgPSAoMCwgX25vcm1hbGl6ZWxvY2FsZXBhdGgubm9ybWFsaXplTG9jYWxlUGF0aCkocGF0aG5hbWUsIHRoaXMubG9jYWxlcykucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgdXJsID0gKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHBhcnNlZCk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZEFzID0gKDAsIF9wYXJzZXJlbGF0aXZldXJsLnBhcnNlUmVsYXRpdmVVcmwpKGFzUGF0aCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxlUGF0aFJlc3VsdCA9ICgwLCBfbm9ybWFsaXplbG9jYWxlcGF0aC5ub3JtYWxpemVMb2NhbGVQYXRoKShwYXJzZWRBcy5wYXRobmFtZSwgdGhpcy5sb2NhbGVzKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRBcy5wYXRobmFtZSA9IGxvY2FsZVBhdGhSZXN1bHQucGF0aG5hbWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5sb2NhbGUgPSBsb2NhbGVQYXRoUmVzdWx0LmRldGVjdGVkTG9jYWxlIHx8IHRoaXMuZGVmYXVsdExvY2FsZTtcbiAgICAgICAgICAgICAgICBhc1BhdGggPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkQXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhZ2VzID0gYXdhaXQgdGhpcy5wYWdlTG9hZGVyLmdldFBhZ2VMaXN0KCk7XG4gICAgICAgIGxldCByZXNvbHZlZEFzID0gYXNQYXRoO1xuICAgICAgICBjb25zdCBsb2NhbGUgPSB0eXBlb2Ygb3B0aW9ucy5sb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBvcHRpb25zLmxvY2FsZSB8fCB1bmRlZmluZWQgOiB0aGlzLmxvY2FsZTtcbiAgICAgICAgY29uc3QgaXNNaWRkbGV3YXJlTWF0Y2ggPSBhd2FpdCBtYXRjaGVzTWlkZGxld2FyZSh7XG4gICAgICAgICAgICBhc1BhdGg6IGFzUGF0aCxcbiAgICAgICAgICAgIGxvY2FsZTogbG9jYWxlLFxuICAgICAgICAgICAgcm91dGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0hBU19SRVdSSVRFUyAmJiBhc1BhdGguc3RhcnRzV2l0aChcIi9cIikpIHtcbiAgICAgICAgICAgIGxldCByZXdyaXRlcztcbiAgICAgICAgICAgICh7IF9fcmV3cml0ZXM6IHJld3JpdGVzIH0gPSBhd2FpdCAoMCwgX3JvdXRlbG9hZGVyLmdldENsaWVudEJ1aWxkTWFuaWZlc3QpKCkpO1xuICAgICAgICAgICAgY29uc3QgcmV3cml0ZXNSZXN1bHQgPSAoMCwgX3Jlc29sdmVyZXdyaXRlcy5kZWZhdWx0KSgoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzUGF0aCwgdGhpcy5sb2NhbGUpLCB0cnVlKSwgcGFnZXMsIHJld3JpdGVzLCBwYXJzZWQucXVlcnksIChwKT0+cmVzb2x2ZUR5bmFtaWNSb3V0ZShwLCBwYWdlcyksIHRoaXMubG9jYWxlcyk7XG4gICAgICAgICAgICBpZiAocmV3cml0ZXNSZXN1bHQuZXh0ZXJuYWxEZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc01pZGRsZXdhcmVNYXRjaCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmVkQXMgPSAoMCwgX3JlbW92ZWxvY2FsZS5yZW1vdmVMb2NhbGUpKCgwLCBfcmVtb3ZlYmFzZXBhdGgucmVtb3ZlQmFzZVBhdGgpKHJld3JpdGVzUmVzdWx0LmFzUGF0aCksIHRoaXMubG9jYWxlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXdyaXRlc1Jlc3VsdC5tYXRjaGVkUGFnZSAmJiByZXdyaXRlc1Jlc3VsdC5yZXNvbHZlZEhyZWYpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGlzIGRpcmVjdGx5IG1hdGNoZXMgYSBwYWdlIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBocmVmIHRvXG4gICAgICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNvcnJlY3QgcGFnZSBjaHVuayB0byBiZSBsb2FkZWRcbiAgICAgICAgICAgICAgICBwYXRobmFtZSA9IHJld3JpdGVzUmVzdWx0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSBwYXRobmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTWlkZGxld2FyZU1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKShwYXJzZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwYXJzZWQucGF0aG5hbWUgPSByZXNvbHZlRHluYW1pY1JvdXRlKHBhcnNlZC5wYXRobmFtZSwgcGFnZXMpO1xuICAgICAgICBpZiAoKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhcnNlZC5wYXRobmFtZSkpIHtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gcGFyc2VkLnBhdGhuYW1lO1xuICAgICAgICAgICAgcGFyc2VkLnBhdGhuYW1lID0gcGF0aG5hbWU7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHF1ZXJ5LCAoMCwgX3JvdXRlbWF0Y2hlci5nZXRSb3V0ZU1hdGNoZXIpKCgwLCBfcm91dGVyZWdleC5nZXRSb3V0ZVJlZ2V4KShwYXJzZWQucGF0aG5hbWUpKSgoMCwgX3BhcnNlcGF0aC5wYXJzZVBhdGgpKGFzUGF0aCkucGF0aG5hbWUpIHx8IHt9KTtcbiAgICAgICAgICAgIGlmICghaXNNaWRkbGV3YXJlTWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX01JRERMRVdBUkVfUFJFRkVUQ0ggPT09IFwic3RyaWN0XCIgPyBudWxsIDogYXdhaXQgd2l0aE1pZGRsZXdhcmVFZmZlY3RzKHtcbiAgICAgICAgICAgIGZldGNoRGF0YTogKCk9PmZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhSHJlZjogdGhpcy5wYWdlTG9hZGVyLmdldERhdGFIcmVmKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWY6ICgwLCBfZm9ybWF0dXJsLmZvcm1hdFdpdGhWYWxpZGF0aW9uKSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6IG9yaWdpbmFsUGF0aG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcEludGVycG9sYXRpb246IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGhhc01pZGRsZXdhcmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGlzU2VydmVyUmVuZGVyOiB0aGlzLmlzU3NyLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgYXNQYXRoOiBhc1BhdGgsXG4gICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICogSWYgdGhlcmUgd2FzIGEgcmV3cml0ZSB3ZSBhcHBseSB0aGUgZWZmZWN0cyBvZiB0aGUgcmV3cml0ZSBvbiB0aGVcbiAgICAgKiBjdXJyZW50IHBhcmFtZXRlcnMgZm9yIHRoZSBwcmVmZXRjaC5cbiAgICAgKi8gaWYgKChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmVmZmVjdC50eXBlKSA9PT0gXCJyZXdyaXRlXCIpIHtcbiAgICAgICAgICAgIHBhcnNlZC5wYXRobmFtZSA9IGRhdGEuZWZmZWN0LnJlc29sdmVkSHJlZjtcbiAgICAgICAgICAgIHBhdGhuYW1lID0gZGF0YS5lZmZlY3QucmVzb2x2ZWRIcmVmO1xuICAgICAgICAgICAgcXVlcnkgPSB7XG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXG4gICAgICAgICAgICAgICAgLi4uZGF0YS5lZmZlY3QucGFyc2VkQXMucXVlcnlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlZEFzID0gZGF0YS5lZmZlY3QucGFyc2VkQXMucGF0aG5hbWU7XG4gICAgICAgICAgICB1cmwgPSAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikocGFyc2VkKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgKiBJZiB0aGVyZSBpcyBhIHJlZGlyZWN0IHRvIGFuIGV4dGVybmFsIGRlc3RpbmF0aW9uIHRoZW4gd2UgZG9uJ3QgaGF2ZVxuICAgICAqIHRvIHByZWZldGNoIGNvbnRlbnQgYXMgaXQgd2lsbCBiZSB1bnVzZWQuXG4gICAgICovIGlmICgoZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5lZmZlY3QudHlwZSkgPT09IFwicmVkaXJlY3QtZXh0ZXJuYWxcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvdXRlID0gKDAsIF9yZW1vdmV0cmFpbGluZ3NsYXNoLnJlbW92ZVRyYWlsaW5nU2xhc2gpKHBhdGhuYW1lKTtcbiAgICAgICAgaWYgKGF3YWl0IHRoaXMuX2JmbChhc1BhdGgsIHJlc29sdmVkQXMsIG9wdGlvbnMubG9jYWxlLCB0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5jb21wb25lbnRzW3VybFBhdGhuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICBfX2FwcFJvdXRlcjogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICB0aGlzLnBhZ2VMb2FkZXIuX2lzU3NnKHJvdXRlKS50aGVuKChpc1NzZyk9PntcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNTc2cgPyBmZXRjaE5leHREYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YUhyZWY6IChkYXRhID09IG51bGwgPyB2b2lkIDAgOiBkYXRhLmpzb24pID8gZGF0YSA9PSBudWxsID8gdm9pZCAwIDogZGF0YS5kYXRhSHJlZiA6IHRoaXMucGFnZUxvYWRlci5nZXREYXRhSHJlZih7XG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhc1BhdGg6IHJlc29sdmVkQXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZVxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgaXNTZXJ2ZXJSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBwYXJzZUpTT046IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0Q2FjaGU6IHRoaXMuc2RjLFxuICAgICAgICAgICAgICAgICAgICBwZXJzaXN0Q2FjaGU6ICF0aGlzLmlzUHJldmlldyxcbiAgICAgICAgICAgICAgICAgICAgaXNQcmVmZXRjaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgdW5zdGFibGVfc2tpcENsaWVudENhY2hlOiBvcHRpb25zLnVuc3RhYmxlX3NraXBDbGllbnRDYWNoZSB8fCBvcHRpb25zLnByaW9yaXR5ICYmICEhcHJvY2Vzcy5lbnYuX19ORVhUX09QVElNSVNUSUNfQ0xJRU5UX0NBQ0hFXG4gICAgICAgICAgICAgICAgfSkudGhlbigoKT0+ZmFsc2UpLmNhdGNoKCgpPT5mYWxzZSkgOiBmYWxzZTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdGhpcy5wYWdlTG9hZGVyW29wdGlvbnMucHJpb3JpdHkgPyBcImxvYWRQYWdlXCIgOiBcInByZWZldGNoXCJdKHJvdXRlKVxuICAgICAgICBdKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2hDb21wb25lbnQocm91dGUpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2FuY2VsbGVkID0gZ2V0Q2FuY2VsbGVkSGFuZGxlcih7XG4gICAgICAgICAgICByb3V0ZSxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudFJlc3VsdCA9IGF3YWl0IHRoaXMucGFnZUxvYWRlci5sb2FkUGFnZShyb3V0ZSk7XG4gICAgICAgICAgICBoYW5kbGVDYW5jZWxsZWQoKTtcbiAgICAgICAgICAgIHJldHVybiBjb21wb25lbnRSZXN1bHQ7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaGFuZGxlQ2FuY2VsbGVkKCk7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldERhdGEoZm4pIHtcbiAgICAgICAgbGV0IGNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKT0+e1xuICAgICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jbGMgPSBjYW5jZWw7XG4gICAgICAgIHJldHVybiBmbigpLnRoZW4oKGRhdGEpPT57XG4gICAgICAgICAgICBpZiAoY2FuY2VsID09PSB0aGlzLmNsYykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW5jZWxsZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoXCJMb2FkaW5nIGluaXRpYWwgcHJvcHMgY2FuY2VsbGVkXCIpO1xuICAgICAgICAgICAgICAgIGVyci5jYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldEZsaWdodERhdGEoZGF0YUhyZWYpIHtcbiAgICAgICAgLy8gRG8gbm90IGNhY2hlIFJTQyBmbGlnaHQgcmVzcG9uc2Ugc2luY2UgaXQncyBub3QgYSBzdGF0aWMgcmVzb3VyY2VcbiAgICAgICAgcmV0dXJuIGZldGNoTmV4dERhdGEoe1xuICAgICAgICAgICAgZGF0YUhyZWYsXG4gICAgICAgICAgICBpc1NlcnZlclJlbmRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHBhcnNlSlNPTjogZmFsc2UsXG4gICAgICAgICAgICBpbmZsaWdodENhY2hlOiB0aGlzLnNkYyxcbiAgICAgICAgICAgIHBlcnNpc3RDYWNoZTogZmFsc2UsXG4gICAgICAgICAgICBpc1ByZWZldGNoOiBmYWxzZVxuICAgICAgICB9KS50aGVuKChwYXJhbSk9PntcbiAgICAgICAgICAgIGxldCB7IHRleHQgfSA9IHBhcmFtO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBkYXRhOiB0ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbFByb3BzKENvbXBvbmVudCwgY3R4KSB7XG4gICAgICAgIGNvbnN0IHsgQ29tcG9uZW50OiBBcHAgfSA9IHRoaXMuY29tcG9uZW50c1tcIi9fYXBwXCJdO1xuICAgICAgICBjb25zdCBBcHBUcmVlID0gdGhpcy5fd3JhcEFwcChBcHApO1xuICAgICAgICBjdHguQXBwVHJlZSA9IEFwcFRyZWU7XG4gICAgICAgIHJldHVybiAoMCwgX3V0aWxzLmxvYWRHZXRJbml0aWFsUHJvcHMpKEFwcCwge1xuICAgICAgICAgICAgQXBwVHJlZSxcbiAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgIHJvdXRlcjogdGhpcyxcbiAgICAgICAgICAgIGN0eFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IHJvdXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5yb3V0ZTtcbiAgICB9XG4gICAgZ2V0IHBhdGhuYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgZ2V0IHF1ZXJ5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5xdWVyeTtcbiAgICB9XG4gICAgZ2V0IGFzUGF0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuYXNQYXRoO1xuICAgIH1cbiAgICBnZXQgbG9jYWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5sb2NhbGU7XG4gICAgfVxuICAgIGdldCBpc0ZhbGxiYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc0ZhbGxiYWNrO1xuICAgIH1cbiAgICBnZXQgaXNQcmV2aWV3KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZS5pc1ByZXZpZXc7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHBhdGhuYW1lLCBxdWVyeSwgYXMsIHsgaW5pdGlhbFByb3BzLCBwYWdlTG9hZGVyLCBBcHAsIHdyYXBBcHAsIENvbXBvbmVudCwgZXJyLCBzdWJzY3JpcHRpb24sIGlzRmFsbGJhY2ssIGxvY2FsZSwgbG9jYWxlcywgZGVmYXVsdExvY2FsZSwgZG9tYWluTG9jYWxlcywgaXNQcmV2aWV3IH0pe1xuICAgICAgICAvLyBTZXJ2ZXIgRGF0YSBDYWNoZSAoZnVsbCBkYXRhIHJlcXVlc3RzKVxuICAgICAgICB0aGlzLnNkYyA9IHt9O1xuICAgICAgICAvLyBTZXJ2ZXIgQmFja2dyb3VuZCBDYWNoZSAoSEVBRCByZXF1ZXN0cylcbiAgICAgICAgdGhpcy5zYmMgPSB7fTtcbiAgICAgICAgdGhpcy5pc0ZpcnN0UG9wU3RhdGVFdmVudCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2tleSA9IGNyZWF0ZUtleSgpO1xuICAgICAgICB0aGlzLm9uUG9wU3RhdGUgPSAoZSk9PntcbiAgICAgICAgICAgIGNvbnN0IHsgaXNGaXJzdFBvcFN0YXRlRXZlbnQgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmlzRmlyc3RQb3BTdGF0ZUV2ZW50ID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGUuc3RhdGU7XG4gICAgICAgICAgICBpZiAoIXN0YXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgZ2V0IHN0YXRlIGFzIHVuZGVmaW5lZCBmb3IgdHdvIHJlYXNvbnMuXG4gICAgICAgICAgICAgICAgLy8gIDEuIFdpdGggb2xkZXIgc2FmYXJpICg8IDgpIGFuZCBvbGRlciBjaHJvbWUgKDwgMzQpXG4gICAgICAgICAgICAgICAgLy8gIDIuIFdoZW4gdGhlIFVSTCBjaGFuZ2VkIHdpdGggI1xuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gSW4gdGhlIGJvdGggY2FzZXMsIHdlIGRvbid0IG5lZWQgdG8gcHJvY2VlZCBhbmQgY2hhbmdlIHRoZSByb3V0ZS5cbiAgICAgICAgICAgICAgICAvLyAoYXMgaXQncyBhbHJlYWR5IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgLy8gQnV0IHdlIGNhbiBzaW1wbHkgcmVwbGFjZSB0aGUgc3RhdGUgd2l0aCB0aGUgbmV3IGNoYW5nZXMuXG4gICAgICAgICAgICAgICAgLy8gQWN0dWFsbHksIGZvciAoMSkgd2UgZG9uJ3QgbmVlZCB0byBub3RoaW5nLiBCdXQgaXQncyBoYXJkIHRvIGRldGVjdCB0aGF0IGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNvLCBkb2luZyB0aGUgZm9sbG93aW5nIGZvciAoMSkgZG9lcyBubyBoYXJtLlxuICAgICAgICAgICAgICAgIGNvbnN0IHsgcGF0aG5hbWUsIHF1ZXJ5IH0gPSB0aGlzO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlU3RhdGUoXCJyZXBsYWNlU3RhdGVcIiwgKDAsIF9mb3JtYXR1cmwuZm9ybWF0V2l0aFZhbGlkYXRpb24pKHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgcXVlcnlcbiAgICAgICAgICAgICAgICB9KSwgKDAsIF91dGlscy5nZXRVUkwpKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIF9fTkEgaXMgdXNlZCB0byBpZGVudGlmeSBpZiB0aGUgaGlzdG9yeSBlbnRyeSBjYW4gYmUgaGFuZGxlZCBieSB0aGUgYXBwLXJvdXRlci5cbiAgICAgICAgICAgIGlmIChzdGF0ZS5fX05BKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc3RhdGUuX19OKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2FmYXJpIGZpcmVzIHBvcHN0YXRlZXZlbnQgd2hlbiByZW9wZW5pbmcgdGhlIGJyb3dzZXIuXG4gICAgICAgICAgICBpZiAoaXNGaXJzdFBvcFN0YXRlRXZlbnQgJiYgdGhpcy5sb2NhbGUgPT09IHN0YXRlLm9wdGlvbnMubG9jYWxlICYmIHN0YXRlLmFzID09PSB0aGlzLmFzUGF0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmb3JjZWRTY3JvbGw7XG4gICAgICAgICAgICBjb25zdCB7IHVybCwgYXMsIG9wdGlvbnMsIGtleSB9ID0gc3RhdGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX1NDUk9MTF9SRVNUT1JBVElPTikge1xuICAgICAgICAgICAgICAgIGlmIChtYW51YWxTY3JvbGxSZXN0b3JhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fa2V5ICE9PSBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNuYXBzaG90IGN1cnJlbnQgc2Nyb2xsIHBvc2l0aW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwiX19uZXh0X3Njcm9sbF9cIiArIHRoaXMuX2tleSwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBzZWxmLnBhZ2VYT2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5OiBzZWxmLnBhZ2VZT2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlc3RvcmUgb2xkIHNjcm9sbCBwb3NpdGlvbjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdiA9IHNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJfX25leHRfc2Nyb2xsX1wiICsga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JjZWRTY3JvbGwgPSBKU09OLnBhcnNlKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcmNlZFNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgICAgICAgICBjb25zdCB7IHBhdGhuYW1lIH0gPSAoMCwgX3BhcnNlcmVsYXRpdmV1cmwucGFyc2VSZWxhdGl2ZVVybCkodXJsKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBkb24ndCByZS1yZW5kZXIgb24gaW5pdGlhbCBsb2FkLFxuICAgICAgICAgICAgLy8gY2FuIGJlIGNhdXNlZCBieSBuYXZpZ2F0aW5nIGJhY2sgZnJvbSBhbiBleHRlcm5hbCBzaXRlXG4gICAgICAgICAgICBpZiAodGhpcy5pc1NzciAmJiBhcyA9PT0gKDAsIF9hZGRiYXNlcGF0aC5hZGRCYXNlUGF0aCkodGhpcy5hc1BhdGgpICYmIHBhdGhuYW1lID09PSAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSh0aGlzLnBhdGhuYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBkb3duc3RyZWFtIGFwcGxpY2F0aW9uIHJldHVybnMgZmFsc3ksIHJldHVybi5cbiAgICAgICAgICAgIC8vIFRoZXkgd2lsbCB0aGVuIGJlIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZXZlbnQuXG4gICAgICAgICAgICBpZiAodGhpcy5fYnBzICYmICF0aGlzLl9icHMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2UoXCJyZXBsYWNlU3RhdGVcIiwgdXJsLCBhcywgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3c6IG9wdGlvbnMuc2hhbGxvdyAmJiB0aGlzLl9zaGFsbG93LFxuICAgICAgICAgICAgICAgIGxvY2FsZTogb3B0aW9ucy5sb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgaW50ZXJuYWwgdmFsdWUgbm90IGV4cG9zZWQgb24gdHlwZXNcbiAgICAgICAgICAgICAgICBfaDogMFxuICAgICAgICAgICAgfSksIGZvcmNlZFNjcm9sbCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIHJlcHJlc2VudHMgdGhlIGN1cnJlbnQgY29tcG9uZW50IGtleVxuICAgICAgICBjb25zdCByb3V0ZSA9ICgwLCBfcmVtb3ZldHJhaWxpbmdzbGFzaC5yZW1vdmVUcmFpbGluZ1NsYXNoKShwYXRobmFtZSk7XG4gICAgICAgIC8vIHNldCB1cCB0aGUgY29tcG9uZW50IGNhY2hlIChieSByb3V0ZSBrZXlzKVxuICAgICAgICB0aGlzLmNvbXBvbmVudHMgPSB7fTtcbiAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCBrZWVwIHRoZSBjYWNoZSwgaWYgdGhlcmUncyBhbiBlcnJvclxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaXMgY2F1c2UgaXNzdWVzIHdoZW4gd2hlbiBnb2luZyBiYWNrIGFuZFxuICAgICAgICAvLyBjb21lIGFnYWluIHRvIHRoZSBlcnJvcmVkIHBhZ2UuXG4gICAgICAgIGlmIChwYXRobmFtZSAhPT0gXCIvX2Vycm9yXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50c1tyb3V0ZV0gPSB7XG4gICAgICAgICAgICAgICAgQ29tcG9uZW50LFxuICAgICAgICAgICAgICAgIGluaXRpYWw6IHRydWUsXG4gICAgICAgICAgICAgICAgcHJvcHM6IGluaXRpYWxQcm9wcyxcbiAgICAgICAgICAgICAgICBlcnIsXG4gICAgICAgICAgICAgICAgX19OX1NTRzogaW5pdGlhbFByb3BzICYmIGluaXRpYWxQcm9wcy5fX05fU1NHLFxuICAgICAgICAgICAgICAgIF9fTl9TU1A6IGluaXRpYWxQcm9wcyAmJiBpbml0aWFsUHJvcHMuX19OX1NTUFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXBvbmVudHNbXCIvX2FwcFwiXSA9IHtcbiAgICAgICAgICAgIENvbXBvbmVudDogQXBwLFxuICAgICAgICAgICAgc3R5bGVTaGVldHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfQ0xJRU5UX1JPVVRFUl9GSUxURVJfRU5BQkxFRCkge1xuICAgICAgICAgICAgY29uc3QgeyBCbG9vbUZpbHRlciB9ID0gcmVxdWlyZShcIi4uLy4uL2xpYi9ibG9vbS1maWx0ZXJcIik7XG4gICAgICAgICAgICBjb25zdCBzdGF0aWNGaWx0ZXJEYXRhID0gcHJvY2Vzcy5lbnYuX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVI7XG4gICAgICAgICAgICBjb25zdCBkeW5hbWljRmlsdGVyRGF0YSA9IHByb2Nlc3MuZW52Ll9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSO1xuICAgICAgICAgICAgaWYgKHN0YXRpY0ZpbHRlckRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRpY0ZpbHRlckRhdGEubnVtSGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX3MgPSBuZXcgQmxvb21GaWx0ZXIoc3RhdGljRmlsdGVyRGF0YS5udW1JdGVtcywgc3RhdGljRmlsdGVyRGF0YS5lcnJvclJhdGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2JmbF9zLmltcG9ydChzdGF0aWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkeW5hbWljRmlsdGVyRGF0YSA9PSBudWxsID8gdm9pZCAwIDogZHluYW1pY0ZpbHRlckRhdGEubnVtSGFzaGVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QgPSBuZXcgQmxvb21GaWx0ZXIoZHluYW1pY0ZpbHRlckRhdGEubnVtSXRlbXMsIGR5bmFtaWNGaWx0ZXJEYXRhLmVycm9yUmF0ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fYmZsX2QuaW1wb3J0KGR5bmFtaWNGaWx0ZXJEYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCYWNrd2FyZHMgY29tcGF0IGZvciBSb3V0ZXIucm91dGVyLmV2ZW50c1xuICAgICAgICAvLyBUT0RPOiBTaG91bGQgYmUgcmVtb3ZlIHRoZSBmb2xsb3dpbmcgbWFqb3IgdmVyc2lvbiBhcyBpdCB3YXMgbmV2ZXIgZG9jdW1lbnRlZFxuICAgICAgICB0aGlzLmV2ZW50cyA9IFJvdXRlci5ldmVudHM7XG4gICAgICAgIHRoaXMucGFnZUxvYWRlciA9IHBhZ2VMb2FkZXI7XG4gICAgICAgIC8vIGlmIGF1dG8gcHJlcmVuZGVyZWQgYW5kIGR5bmFtaWMgcm91dGUgd2FpdCB0byB1cGRhdGUgYXNQYXRoXG4gICAgICAgIC8vIHVudGlsIGFmdGVyIG1vdW50IHRvIHByZXZlbnQgaHlkcmF0aW9uIG1pc21hdGNoXG4gICAgICAgIGNvbnN0IGF1dG9FeHBvcnREeW5hbWljID0gKDAsIF9pc2R5bmFtaWMuaXNEeW5hbWljUm91dGUpKHBhdGhuYW1lKSAmJiBzZWxmLl9fTkVYVF9EQVRBX18uYXV0b0V4cG9ydDtcbiAgICAgICAgdGhpcy5iYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgXCJcIjtcbiAgICAgICAgdGhpcy5zdWIgPSBzdWJzY3JpcHRpb247XG4gICAgICAgIHRoaXMuY2xjID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd3JhcEFwcCA9IHdyYXBBcHA7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBpZ25vcmUgZXh0cmEgcG9wU3RhdGUgaW4gc2FmYXJpIG9uIG5hdmlnYXRpbmdcbiAgICAgICAgLy8gYmFjayBmcm9tIGV4dGVybmFsIHNpdGVcbiAgICAgICAgdGhpcy5pc1NzciA9IHRydWU7XG4gICAgICAgIHRoaXMuaXNMb2NhbGVEb21haW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc1JlYWR5ID0gISEoc2VsZi5fX05FWFRfREFUQV9fLmdzc3AgfHwgc2VsZi5fX05FWFRfREFUQV9fLmdpcCB8fCBzZWxmLl9fTkVYVF9EQVRBX18uYXBwR2lwICYmICFzZWxmLl9fTkVYVF9EQVRBX18uZ3NwIHx8ICFhdXRvRXhwb3J0RHluYW1pYyAmJiAhc2VsZi5sb2NhdGlvbi5zZWFyY2ggJiYgIXByb2Nlc3MuZW52Ll9fTkVYVF9IQVNfUkVXUklURVMpO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gbG9jYWxlcztcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdExvY2FsZSA9IGRlZmF1bHRMb2NhbGU7XG4gICAgICAgICAgICB0aGlzLmRvbWFpbkxvY2FsZXMgPSBkb21haW5Mb2NhbGVzO1xuICAgICAgICAgICAgdGhpcy5pc0xvY2FsZURvbWFpbiA9ICEhKDAsIF9kZXRlY3Rkb21haW5sb2NhbGUuZGV0ZWN0RG9tYWluTG9jYWxlKShkb21haW5Mb2NhbGVzLCBzZWxmLmxvY2F0aW9uLmhvc3RuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgcm91dGUsXG4gICAgICAgICAgICBwYXRobmFtZSxcbiAgICAgICAgICAgIHF1ZXJ5LFxuICAgICAgICAgICAgYXNQYXRoOiBhdXRvRXhwb3J0RHluYW1pYyA/IHBhdGhuYW1lIDogYXMsXG4gICAgICAgICAgICBpc1ByZXZpZXc6ICEhaXNQcmV2aWV3LFxuICAgICAgICAgICAgbG9jYWxlOiBwcm9jZXNzLmVudi5fX05FWFRfSTE4Tl9TVVBQT1JUID8gbG9jYWxlIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgaXNGYWxsYmFja1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSBcImFzXCIgZG9lc24ndCBzdGFydCB3aXRoIGRvdWJsZSBzbGFzaGVzIG9yIGVsc2UgaXQgY2FuXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBlcnJvciBhcyBpdCdzIGNvbnNpZGVyZWQgaW52YWxpZFxuICAgICAgICAgICAgaWYgKCFhcy5zdGFydHNXaXRoKFwiLy9cIikpIHtcbiAgICAgICAgICAgICAgICAvLyBpbiBvcmRlciBmb3IgYGUuc3RhdGVgIHRvIHdvcmsgb24gdGhlIGBvbnBvcHN0YXRlYCBldmVudFxuICAgICAgICAgICAgICAgIC8vIHdlIGhhdmUgdG8gcmVnaXN0ZXIgdGhlIGluaXRpYWwgcm91dGUgdXBvbiBpbml0aWFsaXphdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgYXNQYXRoID0gKDAsIF91dGlscy5nZXRVUkwpKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdGlhbE1hdGNoZXNNaWRkbGV3YXJlUHJvbWlzZSA9IG1hdGNoZXNNaWRkbGV3YXJlKHtcbiAgICAgICAgICAgICAgICAgICAgcm91dGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBsb2NhbGUsXG4gICAgICAgICAgICAgICAgICAgIGFzUGF0aFxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKG1hdGNoZXMpPT57XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuX3Nob3VsZFJlc29sdmVIcmVmID0gYXMgIT09IHBhdGhuYW1lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZVN0YXRlKFwicmVwbGFjZVN0YXRlXCIsIG1hdGNoZXMgPyBhc1BhdGggOiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRXaXRoVmFsaWRhdGlvbikoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aG5hbWU6ICgwLCBfYWRkYmFzZXBhdGguYWRkQmFzZVBhdGgpKHBhdGhuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5XG4gICAgICAgICAgICAgICAgICAgIH0pLCBhc1BhdGgsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hlcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVuYWJsZSBjdXN0b20gc2Nyb2xsIHJlc3RvcmF0aW9uIGhhbmRsaW5nIHdoZW4gYXZhaWxhYmxlXG4gICAgICAgICAgICAvLyBvdGhlcndpc2UgZmFsbGJhY2sgdG8gYnJvd3NlcidzIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5fX05FWFRfU0NST0xMX1JFU1RPUkFUSU9OKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hbnVhbFNjcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID0gXCJtYW51YWxcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5Sb3V0ZXIuZXZlbnRzID0gKDAsIF9taXR0LmRlZmF1bHQpKCk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJvdXRlci5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJtb2R1bGUiLCJkZWZhdWx0IiwibWF0Y2hlc01pZGRsZXdhcmUiLCJjcmVhdGVLZXkiLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJSb3V0ZXIiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX2ludGVyb3BfcmVxdWlyZV93aWxkY2FyZCIsIl9yZW1vdmV0cmFpbGluZ3NsYXNoIiwiX3JvdXRlbG9hZGVyIiwiX3NjcmlwdCIsIl9pc2Vycm9yIiwiXyIsIl9kZW5vcm1hbGl6ZXBhZ2VwYXRoIiwiX25vcm1hbGl6ZWxvY2FsZXBhdGgiLCJfbWl0dCIsIl91dGlscyIsIl9pc2R5bmFtaWMiLCJfcGFyc2VyZWxhdGl2ZXVybCIsIl9yZXNvbHZlcmV3cml0ZXMiLCJfcm91dGVtYXRjaGVyIiwiX3JvdXRlcmVnZXgiLCJfZm9ybWF0dXJsIiwiX2RldGVjdGRvbWFpbmxvY2FsZSIsIl9wYXJzZXBhdGgiLCJfYWRkbG9jYWxlIiwiX3JlbW92ZWxvY2FsZSIsIl9yZW1vdmViYXNlcGF0aCIsIl9hZGRiYXNlcGF0aCIsIl9oYXNiYXNlcGF0aCIsIl9yZXNvbHZlaHJlZiIsIl9pc2FwaXJvdXRlIiwiX2dldG5leHRwYXRobmFtZWluZm8iLCJfZm9ybWF0bmV4dHBhdGhuYW1laW5mbyIsIl9jb21wYXJlc3RhdGVzIiwiX2lzbG9jYWx1cmwiLCJfaXNib3QiLCJfb21pdCIsIl9pbnRlcnBvbGF0ZWFzIiwiX2hhbmRsZXNtb290aHNjcm9sbCIsImJ1aWxkQ2FuY2VsbGF0aW9uRXJyb3IiLCJhc3NpZ24iLCJFcnJvciIsImNhbmNlbGxlZCIsIm9wdGlvbnMiLCJtYXRjaGVycyIsImFzUGF0aG5hbWUiLCJjbGVhbmVkQXMiLCJhc1dpdGhCYXNlUGF0aEFuZExvY2FsZSIsIlByb21pc2UiLCJyZXNvbHZlIiwicm91dGVyIiwicGFnZUxvYWRlciIsImdldE1pZGRsZXdhcmUiLCJwYXJzZVBhdGgiLCJhc1BhdGgiLCJwYXRobmFtZSIsImhhc0Jhc2VQYXRoIiwicmVtb3ZlQmFzZVBhdGgiLCJhZGRCYXNlUGF0aCIsImFkZExvY2FsZSIsImxvY2FsZSIsInNvbWUiLCJtIiwiUmVnRXhwIiwicmVnZXhwIiwidGVzdCIsInN0cmlwT3JpZ2luIiwidXJsIiwib3JpZ2luIiwiZ2V0TG9jYXRpb25PcmlnaW4iLCJzdGFydHNXaXRoIiwic3Vic3RyaW5nIiwibGVuZ3RoIiwicHJlcGFyZVVybEFzIiwiYXMiLCJyZXNvbHZlSHJlZiIsInJlc29sdmVkSHJlZiIsInJlc29sdmVkQXMiLCJocmVmV2FzQWJzb2x1dGUiLCJhc1dhc0Fic29sdXRlIiwicHJlcGFyZWRVcmwiLCJwcmVwYXJlZEFzIiwicmVzb2x2ZUR5bmFtaWNSb3V0ZSIsInBhZ2VzIiwiY2xlYW5QYXRobmFtZSIsInJlbW92ZVRyYWlsaW5nU2xhc2giLCJkZW5vcm1hbGl6ZVBhZ2VQYXRoIiwiaW5jbHVkZXMiLCJwYWdlIiwiaXNEeW5hbWljUm91dGUiLCJnZXRSb3V0ZVJlZ2V4IiwicmUiLCJnZXRNaWRkbGV3YXJlRGF0YSIsInNvdXJjZSIsInJlc3BvbnNlIiwibmV4dENvbmZpZyIsImJhc2VQYXRoIiwiaTE4biIsImxvY2FsZXMiLCJ0cmFpbGluZ1NsYXNoIiwiQm9vbGVhbiIsInByb2Nlc3MiLCJlbnYiLCJfX05FWFRfVFJBSUxJTkdfU0xBU0giLCJyZXdyaXRlSGVhZGVyIiwiaGVhZGVycyIsInJld3JpdGVUYXJnZXQiLCJtYXRjaGVkUGF0aCIsIl9fTkVYVF9FWFRFUk5BTF9NSURETEVXQVJFX1JFV1JJVEVfUkVTT0xWRSIsInBhcnNlZFJld3JpdGVUYXJnZXQiLCJwYXJzZVJlbGF0aXZlVXJsIiwicGF0aG5hbWVJbmZvIiwiZ2V0TmV4dFBhdGhuYW1lSW5mbyIsInBhcnNlRGF0YSIsImZzUGF0aG5hbWUiLCJnZXRQYWdlTGlzdCIsImdldENsaWVudEJ1aWxkTWFuaWZlc3QiLCJ0aGVuIiwicGFyYW0iLCJfX3Jld3JpdGVzIiwicmV3cml0ZXMiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwicGFyc2VkU291cmNlIiwiX19ORVhUX0hBU19SRVdSSVRFUyIsInVuZGVmaW5lZCIsInJlc3VsdCIsInF1ZXJ5IiwicGF0aCIsIm1hdGNoZWRQYWdlIiwicGFyc2VkQXMiLCJyZXNvbHZlZFBhdGhuYW1lIiwibWF0Y2hlcyIsImdldFJvdXRlTWF0Y2hlciIsInR5cGUiLCJzcmMiLCJmb3JtYXROZXh0UGF0aG5hbWVJbmZvIiwiZGVmYXVsdExvY2FsZSIsImJ1aWxkSWQiLCJkZXN0aW5hdGlvbiIsImhhc2giLCJyZWRpcmVjdFRhcmdldCIsIm5ld0FzIiwibmV3VXJsIiwid2l0aE1pZGRsZXdhcmVFZmZlY3RzIiwiZGF0YSIsImVmZmVjdCIsImUiLCJmZXRjaERhdGEiLCJkYXRhSHJlZiIsImpzb24iLCJ0ZXh0IiwiY2FjaGVLZXkiLCJtYW51YWxTY3JvbGxSZXN0b3JhdGlvbiIsIl9fTkVYVF9TQ1JPTExfUkVTVE9SQVRJT04iLCJ3aW5kb3ciLCJoaXN0b3J5IiwidiIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJuIiwiU1NHX0RBVEFfTk9UX0ZPVU5EIiwiU3ltYm9sIiwiZmV0Y2hSZXRyeSIsImF0dGVtcHRzIiwiZmV0Y2giLCJjcmVkZW50aWFscyIsIm1ldGhvZCIsIm9rIiwic3RhdHVzIiwidHJ5VG9QYXJzZUFzSlNPTiIsIkpTT04iLCJwYXJzZSIsImVycm9yIiwiZmV0Y2hOZXh0RGF0YSIsImluZmxpZ2h0Q2FjaGUiLCJpc1ByZWZldGNoIiwiaGFzTWlkZGxld2FyZSIsImlzU2VydmVyUmVuZGVyIiwicGFyc2VKU09OIiwicGVyc2lzdENhY2hlIiwiaXNCYWNrZ3JvdW5kIiwidW5zdGFibGVfc2tpcENsaWVudENhY2hlIiwiVVJMIiwibG9jYXRpb24iLCJocmVmIiwiX3BhcmFtc19tZXRob2QiLCJnZXREYXRhIiwicGFyYW1zIiwicHVycG9zZSIsIl90cnlUb1BhcnNlQXNKU09OIiwibm90Rm91bmQiLCJtYXJrQXNzZXRFcnJvciIsImNhdGNoIiwiZXJyIiwibWVzc2FnZSIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInNsaWNlIiwiaGFuZGxlSGFyZE5hdmlnYXRpb24iLCJnZXRDYW5jZWxsZWRIYW5kbGVyIiwicm91dGUiLCJjYW5jZWwiLCJjbGMiLCJoYW5kbGVDYW5jZWxsZWQiLCJpbml0aWFsUHJvcHMiLCJBcHAiLCJ3cmFwQXBwIiwiQ29tcG9uZW50Iiwic3Vic2NyaXB0aW9uIiwiaXNGYWxsYmFjayIsImRvbWFpbkxvY2FsZXMiLCJpc1ByZXZpZXciLCJzZGMiLCJzYmMiLCJpc0ZpcnN0UG9wU3RhdGVFdmVudCIsIl9rZXkiLCJvblBvcFN0YXRlIiwic3RhdGUiLCJjaGFuZ2VTdGF0ZSIsImZvcm1hdFdpdGhWYWxpZGF0aW9uIiwiZ2V0VVJMIiwiX19OQSIsInJlbG9hZCIsIl9fTiIsImZvcmNlZFNjcm9sbCIsImtleSIsInN0cmluZ2lmeSIsIngiLCJzZWxmIiwicGFnZVhPZmZzZXQiLCJ5IiwicGFnZVlPZmZzZXQiLCJnZXRJdGVtIiwiaXNTc3IiLCJfYnBzIiwiY2hhbmdlIiwic2hhbGxvdyIsIl9zaGFsbG93IiwiX2giLCJjb21wb25lbnRzIiwiaW5pdGlhbCIsInByb3BzIiwiX19OX1NTRyIsIl9fTl9TU1AiLCJzdHlsZVNoZWV0cyIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0ZJTFRFUl9FTkFCTEVEIiwiQmxvb21GaWx0ZXIiLCJzdGF0aWNGaWx0ZXJEYXRhIiwiX19ORVhUX0NMSUVOVF9ST1VURVJfU19GSUxURVIiLCJkeW5hbWljRmlsdGVyRGF0YSIsIl9fTkVYVF9DTElFTlRfUk9VVEVSX0RfRklMVEVSIiwibnVtSGFzaGVzIiwiX2JmbF9zIiwibnVtSXRlbXMiLCJlcnJvclJhdGUiLCJpbXBvcnQiLCJfYmZsX2QiLCJldmVudHMiLCJhdXRvRXhwb3J0RHluYW1pYyIsIl9fTkVYVF9EQVRBX18iLCJhdXRvRXhwb3J0IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInN1YiIsIl93cmFwQXBwIiwiaXNMb2NhbGVEb21haW4iLCJpc1JlYWR5IiwiZ3NzcCIsImdpcCIsImFwcEdpcCIsImdzcCIsInNlYXJjaCIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJkZXRlY3REb21haW5Mb2NhbGUiLCJob3N0bmFtZSIsIl9pbml0aWFsTWF0Y2hlc01pZGRsZXdhcmVQcm9taXNlIiwiX3Nob3VsZFJlc29sdmVIcmVmIiwiYWRkRXZlbnRMaXN0ZW5lciIsInNjcm9sbFJlc3RvcmF0aW9uIiwiYmFjayIsImZvcndhcmQiLCJwdXNoIiwicmVwbGFjZSIsIl9iZmwiLCJza2lwTmF2aWdhdGUiLCJtYXRjaGVzQmZsU3RhdGljIiwibWF0Y2hlc0JmbER5bmFtaWMiLCJjdXJBcyIsImFzTm9TbGFzaCIsImFzTm9TbGFzaExvY2FsZSIsIl90aGlzX19iZmxfcyIsIl90aGlzX19iZmxfczEiLCJub3JtYWxpemVkQVMiLCJjdXJBc1BhcnRzIiwiaSIsIl90aGlzX19iZmxfZCIsImN1cnJlbnRQYXJ0IiwiY29udGFpbnMiLCJzcGxpdCIsImpvaW4iLCJfdGhpc19jb21wb25lbnRzX3BhdGhuYW1lIiwiaXNRdWVyeVVwZGF0aW5nIiwic2hvdWxkUmVzb2x2ZUhyZWYiLCJuZXh0U3RhdGUiLCJyZWFkeVN0YXRlQ2hhbmdlIiwicHJldkxvY2FsZSIsImxvY2FsZVBhdGhSZXN1bHQiLCJkaWROYXZpZ2F0ZSIsIl90aGlzX2xvY2FsZXMiLCJkZXRlY3RlZERvbWFpbiIsImFzTm9CYXNlUGF0aCIsInNjcm9sbCIsInJvdXRlUHJvcHMiLCJsb2NhbGVDaGFuZ2UiLCJwYXJzZWQiLCJwYXJzZWRBc1BhdGhuYW1lIiwiaXNNaWRkbGV3YXJlUmV3cml0ZSIsImlzTWlkZGxld2FyZU1hdGNoIiwicmV3cml0ZXNSZXN1bHQiLCJyb3V0ZU1hdGNoIiwicm91dGVSZWdleCIsInNob3VsZEludGVycG9sYXRlIiwiaW50ZXJwb2xhdGVkQXMiLCJtaXNzaW5nUGFyYW1zIiwiaXNFcnJvclJvdXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMiLCJfc2VsZl9fX05FWFRfREFUQV9fX3Byb3BzIiwiX3JvdXRlSW5mb19wcm9wcyIsInJvdXRlSW5mbyIsImNsZWFuZWRQYXJzZWRQYXRobmFtZSIsInByZWZpeGVkQXMiLCJyZXdyaXRlQXMiLCJsb2NhbGVSZXN1bHQiLCJjdXJSb3V0ZU1hdGNoIiwiY29tcG9uZW50Iiwic2NyaXB0cyIsInBhcnNlZEhyZWYiLCJub3RGb3VuZFJvdXRlIiwiX3JvdXRlSW5mb19yb3V0ZSIsImlzVmFsaWRTaGFsbG93Um91dGUiLCJfb3B0aW9uc19zY3JvbGwiLCJzaG91bGRTY3JvbGwiLCJyZXNldFNjcm9sbCIsInVwY29taW5nU2Nyb2xsU3RhdGUiLCJ1cGNvbWluZ1JvdXRlclN0YXRlIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wc19wYWdlUHJvcHMxIiwiX3NlbGZfX19ORVhUX0RBVEFfX19wcm9wczEiLCJfcm91dGVJbmZvX3Byb3BzMSIsImNhblNraXBVcGRhdGluZyIsImhhc2hSZWdleCIsImlzTG9jYWxVUkwiLCJkZXRlY3RlZExvY2FsZSIsImRvbWFpbiIsImh0dHAiLCJTVCIsInBlcmZvcm1hbmNlIiwibWFyayIsIl9pbkZsaWdodFJvdXRlIiwiZW1pdCIsInJlbW92ZUxvY2FsZSIsIm9ubHlBSGFzaENoYW5nZSIsInNjcm9sbFRvSGFzaCIsInNldCIsIl9fYXBwUm91dGVyIiwidXJsSXNOZXciLCJwIiwiZXh0ZXJuYWxEZXN0IiwiaW50ZXJwb2xhdGVBcyIsImtleXMiLCJncm91cHMiLCJmaWx0ZXIiLCJvcHRpb25hbCIsImNvbnNvbGUiLCJ3YXJuIiwib21pdCIsImdldFJvdXRlSW5mbyIsImZvckVhY2giLCJ1bnN0YWJsZV9zY3JpcHRMb2FkZXIiLCJjb25jYXQiLCJzY3JpcHQiLCJoYW5kbGVDbGllbnRTY3JpcHRMb2FkIiwicGFnZVByb3BzIiwiX19OX1JFRElSRUNUIiwiX19OX1JFRElSRUNUX0JBU0VfUEFUSCIsIl9fTl9QUkVWSUVXIiwiZmV0Y2hDb21wb25lbnQiLCJpc05vdEZvdW5kIiwic3RhdHVzQ29kZSIsImNvbXBhcmVSb3V0ZXJTdGF0ZXMiLCJkb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsImxhbmciLCJoYW5kbGVSb3V0ZUluZm9FcnJvciIsImxvYWRFcnJvckZhaWwiLCJnaXBFcnIiLCJyb3V0ZUluZm9FcnIiLCJpc0Fzc2V0RXJyb3IiLCJnZXRJbml0aWFsUHJvcHMiLCJyZXF1ZXN0ZWRSb3V0ZSIsIl9kYXRhX2VmZmVjdCIsIl9kYXRhX2VmZmVjdDEiLCJfZGF0YV9lZmZlY3QyIiwiX2RhdGFfcmVzcG9uc2UiLCJleGlzdGluZ0luZm8iLCJjYWNoZWRSb3V0ZUluZm8iLCJmZXRjaE5leHREYXRhUGFyYW1zIiwicmVzb2x2ZWRSb3V0ZSIsImlzVmFsaWRFbGVtZW50VHlwZSIsIndhc0JhaWxlZFByZWZldGNoIiwic2hvdWxkRmV0Y2hEYXRhIiwiZ2V0RGF0YUhyZWYiLCJza2lwSW50ZXJwb2xhdGlvbiIsImlzQVBJUm91dGUiLCJyZXMiLCJtb2QiLCJfZ2V0RGF0YSIsImZldGNoZWQiLCJnZXRQcm9wZXJFcnJvciIsImJlZm9yZVBvcFN0YXRlIiwiY2IiLCJvbGRVcmxOb0hhc2giLCJvbGRIYXNoIiwibmV3VXJsTm9IYXNoIiwibmV3SGFzaCIsImhhbmRsZVNtb290aFNjcm9sbCIsInNjcm9sbFRvIiwicmF3SGFzaCIsImRlY29kZVVSSUNvbXBvbmVudCIsImlkRWwiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3IiwibmFtZUVsIiwiZ2V0RWxlbWVudHNCeU5hbWUiLCJvbmx5SGFzaENoYW5nZSIsInByZWZldGNoIiwidXJsUGF0aG5hbWUiLCJvcmlnaW5hbFBhdGhuYW1lIiwiaXNCb3QiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJfX05FWFRfTUlERExFV0FSRV9QUkVGRVRDSCIsIl9pc1NzZyIsImlzU3NnIiwicHJpb3JpdHkiLCJfX05FWFRfT1BUSU1JU1RJQ19DTElFTlRfQ0FDSEUiLCJjb21wb25lbnRSZXN1bHQiLCJsb2FkUGFnZSIsImZuIiwiX2dldEZsaWdodERhdGEiLCJjdHgiLCJBcHBUcmVlIiwibG9hZEdldEluaXRpYWxQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/shared/lib/router/router.js\n"));

/***/ })

});